<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shmilyvidian</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/shmilyvidian.site/"/>
  <updated>2018-01-26T16:34:00.970Z</updated>
  <id>/shmilyvidian.site/</id>
  
  <author>
    <name>shmilyvidian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数组去重</title>
    <link href="/shmilyvidian.site/2018/01/27/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D/"/>
    <id>/shmilyvidian.site/2018/01/27/数组去重/</id>
    <published>2018-01-26T16:23:20.000Z</published>
    <updated>2018-01-26T16:34:00.970Z</updated>
    
    <content type="html"><![CDATA[<p>//数组去重方法汇总<br>var arr = [1,2,3,4,3,2,3,3,4,5];</p><p>//1.利用es6新特性Set值不会重复的特性去重然后用Array.from转成数组<br>console.log(Array.from(new Set(arr)))</p><p>//2.利用对象key是唯一的特性去重<br>//将数组转成对象<br>function convertObj(arr){<br>  var obj = {};<br>  if(arr instanceof Array){<br>    for(var i=0,len=arr.length;i&lt;len;i++){<br>      obj[arr[i]] = true<br>    }<br>  }<br>  return obj;<br>}</p><p>//将对象转成数组<br>function convertArr(obj){<br>  var arr = [];<br>  for(item in obj){<br>    if(obj.hasOwnProperty(item)){<br>      arr.push(item)<br>    }<br>  }<br>  return arr<br>}<br>function uniq(arr){<br>  return convertArr(convertObj(arr))<br>}<br>console.log(uniq(arr))</p><p>//3.利用indexOf找到第一项即停止的特性过滤重复项<br>function uniq(arr){<br>  var newArr = [];<br>  for(var i = 0,len=arr.length;i&lt;len;i++){<br>    if(newArr.indexOf(arr[i])==-1){<br>      newArr.push(arr[i])<br>    }<br>  }<br>  return newArr<br>}<br>console.log(uniq(arr))</p><p>//4.利用filter循环加上indexOf找到第一项即停止的特性过滤重复项<br>function uniq(arr){<br>  return Array.prototype.filter.call(arr,function(item,idx){return arr.indexOf(item) == idx})<br>}<br>console.log(uniq(arr))</p><p>//5.<br>function unique(arr) {<br>  var obj = {};<br>  return array.filter(function(item, index, array){<br>    return obj.hasOwnProperty(item) ? false : (obj[item] = true)<br>  })<br>}<br>console.log(unique(arr));</p><p>//6.<br>function unique(a) {<br>  var res = [];<br>  for (var i = 0, len = a.length; i &lt; len; i++) {<br>    for (var j = i + 1; j &lt; len; j++) {<br>      if (a[i] === a[j])<br>        j = ++i;<br>    }<br>    res.push(a[i]);<br>  }<br>  return res;<br>}<br>console.log(unique(arr)); // [1, 2]</p><p>//7.<br>function uniq(arr){<br>  var sortArr = Array.prototype.sort.call(arr);<br>  console.log(sortArr)<br>  var result = [];<br>   sortArr.reduce((v1,v2)=&gt;{<br>     if(v1 !== v2){<br>       result.push(v1)<br>     }<br>     return v2<br>   })<br>   result.push(sortArr[sortArr.length - 1]);<br>  return result;<br>}<br>console.log(uniq(arr))</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;//数组去重方法汇总&lt;br&gt;var arr = [1,2,3,4,3,2,3,3,4,5];&lt;/p&gt;
&lt;p&gt;//1.利用es6新特性Set值不会重复的特性去重然后用Array.from转成数组&lt;br&gt;console.log(Array.from(new Set(arr)))
      
    
    </summary>
    
      <category term="JAVASCRIPT  分类" scheme="/shmilyvidian.site/categories/JAVASCRIPT-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>RN在windows平台搭建android环境</title>
    <link href="/shmilyvidian.site/2018/01/27/RN%E5%9C%A8windows%E5%B9%B3%E5%8F%B0%E6%90%AD%E5%BB%BAandroid%E7%8E%AF%E5%A2%83/"/>
    <id>/shmilyvidian.site/2018/01/27/RN在windows平台搭建android环境/</id>
    <published>2018-01-26T16:22:54.000Z</published>
    <updated>2018-01-26T16:30:55.238Z</updated>
    
    <content type="html"><![CDATA[<p>RN在windows平台搭建android环境<br>⦁    安装windows平台包管理器Chocolatey<br>Chocolatey是一个基于Nuget的Windows包管理工具。Chocolatey 只是把官方下载路径封装到了 Chocolatey 中，所以下载源都是其官方路径，所以下载的渠道肯定是正规安全合法的。官方网址：<a href="https://chocolatey.org/。" target="_blank" rel="external">https://chocolatey.org/。</a><br>方法一：以管理员身份打开cmd输入下面指令即可：<br>@powershell -NoProfile -ExecutionPolicy Bypass -Command “iex ((new-object net.webclient).DownloadString(‘<a href="https://chocolatey.org/install.ps1" target="_blank" rel="external">https://chocolatey.org/install.ps1</a>‘))” &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin<br>方法二：或者打开管理员权限的Powershell，然后输入以下命令：iex ((new-object net.webclient).DownloadString(‘<a href="https://chocolatey.org/install.ps1" target="_blank" rel="external">https://chocolatey.org/install.ps1</a>‘))<br>使用choco  -v验证是否安装成功<br>常用命令：<br>choco search命令：choco search 关键字 搜索出所有包含关键字的软件包<br>choco install命令：choco install 软件包名称        安装对应的软件包。<br>choco update命令：choco upgrade 软件包名称    更新对应的软件包。<br>choco uninstall命令：choco uninstall 软件包名称       卸载指定的软件包。<br>常见问题：如果输入choco install <em>*</em>报错useFIpCompliantChecksums也得开启</p><p>⦁    安装nodejs，版本需要大于4.0<br>方法一：<a href="https://nodejs.org/en/download/下载：https://nodejs.org/en/download/" target="_blank" rel="external">https://nodejs.org/en/download/下载：https://nodejs.org/en/download/</a><br>方法二：Choco install node<br>⦁    安装python2，暂支持版本2<br>方法一：choco install -python2<br>方法二： <a href="https://www.python.org/downloads/" target="_blank" rel="external">https://www.python.org/downloads/</a><br>⦁    安装JDK，版本8.0<br>React-native是需要java的运行环境，所以要安装JDK。<br>choco install jdk8<br>⦁    安装RN脚手架React Native CLI<br>npm install -g react-native-cli<br>⦁    安装Android Studio<br>地址：<a href="https://developer.android.google.cn/index.html" target="_blank" rel="external">https://developer.android.google.cn/index.html</a><br>点击下载的安装包，流程一步一步下面有描述：</p><p>到此Android-studio的安装就完成了。初次进入会比较慢，由于要先下载各种依赖包和Gradle 项目需要下载 Gradle 。</p><p>常见问题：<br>初次进入可能会遇到报没有SDK list无法进入软件，</p><p>解决方法：<br>（1）在Android Studio安装目录下的 bin 目录下，找到 idea.properties 文件<br>（2）在文件最后追加disable.android.first.run=true<br>（3）直接点Cancel跳过这一步。如果你后期需要更新SDK，可点击上面的“二、资源下载”中最后的那个红色链接，下载需要的安装包离线进行配置</p><p>进入android-studio点击Cofigure选择SDK Manager</p><p>SDK Platforms中安装</p><ol><li>Google APIs</li><li>Android SDK Platform 23</li><li>Intel x86 Atom_64 System Image</li><li>Google APIs Intel x86 Atom_64 System Image</li></ol><p>SDK tools中安装</p><p>⦁    配置环境android环境变量</p><ol><li><p>环境变量中创建一个ANDROID_HOME，值是存放你android sdk的地址</p></li><li><p>在path中加上android的tools和platform-tools<br>%ANDROID_HOME%\tools;%ANDROID_HOME%\platform-tools;<br>⦁    创建一个RN程序<br>react-native init AwesomeProject （init后面你可以自定义app名字）<br>⦁    启动项目<br>如果打开目录在项目的android目录点击avd图标 没有模拟器，很可能是你在安装android-studio选择Custom没安装完全东西，完整的安装是下面四项都需要打钩</p></li><li>Android SDK</li><li>Android SDK Platform</li><li>Performance (Intel ® HAXM)</li><li>Android Virtual Device<br>按照上面安装的流程一步一步来是有模拟器，如果没有就在打开的弹窗右下角有一个创建 create a new AVD</li></ol><p>然后一路安装就行了。<br>模拟器的启动需要电脑启 vt虚拟化技术，在BIOS中找到Configuration配置选即可<br> s<br>参考博客地址：<a href="https://jingyan.baidu.com/article/9f7e7ec0b3b5a26f281554c6.html" target="_blank" rel="external">https://jingyan.baidu.com/article/9f7e7ec0b3b5a26f281554c6.html</a><br>进入项目根目录控制台执行react-native run-android这一步需要确保已经打开了模拟器</p><p>初次安装app到模拟器可能会出现这样的情况，这个时候在项目根目录执行react-native start开启服务即可解决。<br>⦁    简单调试</p><ol><li>双击R刷新</li><li><p>Ctrl+m调出开发菜单</p></li><li><p>Debug JS Remotely<br>点击远程调试会打开chrome浏览器<a href="http://localhost:8081/debugger-ui/" target="_blank" rel="external">http://localhost:8081/debugger-ui/</a></p></li><li>全局加载或局部热加载</li></ol><p>启动第一项你每次修改完代码会自动刷新整个页面<br>启动第二项你每次修改代码会自动刷新对应你修改的地方<br>⦁    安装genymotion模拟器</p><ol><li><p>官网注册</p></li><li><p>下载<br>因为Genymotion运行需要VirtualBox，如果电脑中没安装过，建议选这个版本。<br>不选择也可以单独在官网下载VirtualBox。</p></li><li><p>安装<br>运行安装Genymotion<br>双击运行下载的Genymotion安装文件,如若不做特定的路径修改你可以一路点击下一步完成安装，再安装完Genymotion后,会继续安装VirtualBox，同样是点击下一步完成安装。</p></li><li>进入Genymotion页面<br>初次进入Genymotion,会检查你是否有安卓虚拟设备。如果没有会弹出对话框，询问你是否现在添加一个虚拟设备,点击yes即可。<br>创建虚拟设备需要输入你在官网注册的账号密码然后点击Connect，如果看到</li></ol><p>验证账号密码之后会看到很多供你选择的虚拟设备，选择你想添加的设备下一步等待安装成功。</p><ol><li>在android-studio配置Genymotion<br>在Genymotion中配置sdk地址</li></ol><p>在android-studio安装Genymotion插件<br>选择File=&gt;Setting=&gt;Plugins=&gt;然后在右边搜索栏搜索Genymotion，点击安装，安装后要重启Studio。</p><p>项目构建安装成功就可以在虚拟设备中看到你的app</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;RN在windows平台搭建android环境&lt;br&gt;⦁    安装windows平台包管理器Chocolatey&lt;br&gt;Chocolatey是一个基于Nuget的Windows包管理工具。Chocolatey 只是把官方下载路径封装到了 Chocolatey 中，所以下载
      
    
    </summary>
    
      <category term="ppt  分类" scheme="/shmilyvidian.site/categories/ppt-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>RegExp</title>
    <link href="/shmilyvidian.site/2017/12/24/RegExp/"/>
    <id>/shmilyvidian.site/2017/12/24/RegExp/</id>
    <published>2017-12-23T17:55:26.000Z</published>
    <updated>2018-01-05T14:08:33.494Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/12/24/RegExp/images/regexp.jpg" alt="regexp" title="regexp"></p><h1 id="正则表达式的基础"><a href="#正则表达式的基础" class="headerlink" title="正则表达式的基础"></a>正则表达式的基础</h1><ul><li>起源</li><li>正则是什么</li><li>如何创建一个正则</li><li>如何学习正则</li><li>正则的转义</li><li>正则的组成</li><li>修饰符</li><li>元字符</li><li>字符类</li><li>范围类</li><li>预定义类</li><li>边界</li><li>量词</li><li>贪婪模式</li><li>非贪婪模式</li><li>分组</li><li>反向引用</li><li>忽略分组</li><li>前瞻后顾</li><li>对象属性</li><li>正则方法</li><li><p>字符串方法</p><h1 id="1、正则是什么？"><a href="#1、正则是什么？" class="headerlink" title="1、正则是什么？"></a>1、正则是什么？</h1></li><li><p>起源：正则表达式的“祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。<br>1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为“神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为“正则集的代数”的表达式，因此采用“正则表达式”这个术语。<br>随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。<br>如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。</p></li><li>正则：它就是一个匹配规则，用来搜索和匹配的工具，记录文本的代码。</li></ul><h1 id="2、如何创建一个正则"><a href="#2、如何创建一个正则" class="headerlink" title="2、如何创建一个正则?"></a>2、如何创建一个正则?</h1><ul><li><p>字面量方式:</p><p>  var reg = /\d/;</p></li><li><p>构造函数方式:</p><p>  var reg = new RegExp(“”);</p></li></ul><p><strong>正则的两种创建方式是有区别的</strong></p><p>　　在字面量方式中,我们//之间包起来的所有的内容都是元字符,有的具有特殊的意义,大部分都是代表本身含义的普通的元字符</p><ul><li>字面量方式中出现的一切都是元字符,所以不能进行变量值的拼接,而实例创建的正则表达式可以使用变量；</li><li>字面量方式中直接写\d就可以,而在实例中需要把它转译 \d</li><li>要注意的是，传递给 RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给 RegExp 构造函数）。由于 RegExp 构造<br>函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。</li></ul><h1 id="3、如何学习正则"><a href="#3、如何学习正则" class="headerlink" title="3、如何学习正则?"></a>3、如何学习正则?</h1><ul><li>MDN文档</li><li>RegExp.prototype查看具体api</li><li><a href="https://github.com/javallone/regexper-static" target="_blank" rel="external">regexper</a> ‘正则测试工具’</li><li>多练多理解</li></ul><h1 id="4、正则转义"><a href="#4、正则转义" class="headerlink" title="4、正则转义"></a>4、正则转义</h1><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p><p>( [ { \ ^ $ | ) ? * + .]}</p><p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p><h1 id="5、正则表达式是由普通字符（例如字符a-z）以及特殊字符（称为元字符）组成的文字模式。"><a href="#5、正则表达式是由普通字符（例如字符a-z）以及特殊字符（称为元字符）组成的文字模式。" class="headerlink" title="5、正则表达式是由普通字符（例如字符a~z）以及特殊字符（称为元字符）组成的文字模式。"></a>5、正则表达式是由普通字符（例如字符a~z）以及特殊字符（称为元字符）组成的文字模式。</h1><h1 id="6、正则修饰符-默认都是false-可读不可写"><a href="#6、正则修饰符-默认都是false-可读不可写" class="headerlink" title="6、正则修饰符(默认都是false,可读不可写)"></a>6、正则修饰符(默认都是false,可读不可写)</h1><ul><li><p>1)i(ingore case)：大小写不敏感。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;Hello&apos;;</div><div class="line">var regexp1 = /hello/,regexp2 = /hello/i;</div><div class="line">regexp1.test(str) =&gt; false</div><div class="line">regexp2.test(str) =&gt; true</div></pre></td></tr></table></figure></li><li><p>2)g(global)：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;hello Elin&apos;;</div><div class="line">var regexp1 = /e/g,regexp2 = /e/ig;</div><div class="line">str.replace(regexp1,&apos;A&apos;); =&gt; &apos;hAllo Elin&apos;</div><div class="line">str.replace(regexp1,&apos;A&apos;); =&gt; &apos;hAllo Alin&apos;</div></pre></td></tr></table></figure></li><li><p>3)m(multiple)：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用，若不指定 m，则：^ 只在字符串的最开头，$ 只在字符串的最结尾；若指定 m，则：^ 在字符串每一行的开头，$ 在字符串每一行的结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    var a = `</div><div class="line">123</div><div class="line">abc</div><div class="line">456</div><div class="line">`;</div><div class="line">    a.match(/^\d+$/) =&gt; null</div><div class="line">    a.match(/^\d+$/m) =&gt; [&apos;123&apos;]</div><div class="line">    a.match(/^\d+$/gm) =&gt; [&apos;123&apos;,&apos;456&apos;]</div></pre></td></tr></table></figure></li></ul><h1 id="7、元字符"><a href="#7、元字符" class="headerlink" title="7、元字符"></a>7、元字符</h1><p>正则表达式由原义文本字符和元字符组成。<br>常用的元字符<br> 代码                           | 说明          | reg<br> —|—————————-|————–|——-<br> .  | 匹配除换行符以外的任意字符   | [^\r\n]<br> \w | 匹配字母或数字或下划线或汉字 |   [a-zA-Z_0-9]<br> \s | 匹配任意的空白符            |    [ \f\n\r\t\v]<br> \d | 匹配数字                   | [0-9]<br> ^  | 匹配字符串的开始            |<br> $  | 匹配字符串的结束            |</p><h1 id="8、字符类"><a href="#8、字符类" class="headerlink" title="8、字符类"></a>8、字符类</h1><p>元字符[]构建一个简单的类，此时的类是符合某些特征的对象。使用方括号[]包括一系列字符，能够匹配其中任意一个字符。</p><ul><li><p>[]里面以^开始表示非的意思，下面表示可以匹配到a b c之外的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[^abc]</div></pre></td></tr></table></figure></li><li><p>字符类区间，你可以在字符类中使用连字符来表示一个字母或者数字的区间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[\d]  ==  [0-9]</div><div class="line">[a-e] == [abcde]</div></pre></td></tr></table></figure></li></ul><h1 id="9、范围类"><a href="#9、范围类" class="headerlink" title="9、范围类"></a>9、范围类</h1><ul><li>在正则表示一类方法的需要用到字符类[],所谓类就是符合某些特征的对象，泛指而不是具体的某个字符。<br>例如上述例子中[abc]就是把字母a、b、c归为一类</li><li><p>中间使用连字符‘-’来连接两个字符表示从开始字符到结尾字符的任意字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[a-zA-z-0-9] == \w</div></pre></td></tr></table></figure></li><li><p>如果范围类中又想匹配到‘ - ’，但是我们知道-在[]内部表示范围，当我们需要匹配’-‘时可以直接加载在后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[a-zA-z-0-9-]</div><div class="line">var string = &apos;a1b-2c3c-cee654A-DAD&apos;;</div><div class="line">   string = string.replace(/[a-zA-Z0-9-]/g, &apos;X&apos;);</div><div class="line">   console.log(string) ==&gt; &apos;XXXXXXXXXXXXXXXXXXXX&apos;</div></pre></td></tr></table></figure></li></ul><h1 id="10、预定义类"><a href="#10、预定义类" class="headerlink" title="10、预定义类"></a>10、预定义类</h1><ul><li>正则表达式提供了一些</li><li>常见预定义类：  <ul><li>字符 - 含义 </li><li>.   [^\r\n] 除了回车换行之外的所有字符 </li><li>\d  [0-9] 数字字符 digital</li><li>\D  [^0-9] 非数字字符 digital</li><li>\s  [\t\n\x0B\f\r] 空白字符 space</li><li>\S  [^\t\n\x0B\f\r] 非空白字符 space</li><li>\w  [a-zA-Z0-9_] 字母数字下划线 word</li><li>\W  非字母数字下划线 word</li></ul></li></ul><h1 id="11、边界"><a href="#11、边界" class="headerlink" title="11、边界"></a>11、边界</h1><ul><li>正则表达式提供了几种常见的边界匹配字符<ul><li>字符 - 含义 <ul><li>^    以什么开始</li><li>$    以什么结束</li><li>\b   单词边界</li><li>\B   非单词边界 </li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var string = &apos;this is a boy, this is a girl&apos;;</div><div class="line">   string = string.replace(/\bis\b/g, &apos;my&apos;)</div><div class="line">   console.log(string); ==&gt; this my a boy, this my a girl</div></pre></td></tr></table></figure><h1 id="12、-量词"><a href="#12、-量词" class="headerlink" title="12、 量词"></a>12、 量词</h1><ul><li>量词是正则中的限定符。<ul><li>‘*’    重复零次或更多次</li><li>‘+’    重复一次或更多次</li><li>‘?’    重复零次或一次</li><li>{n} 重复n次</li><li>{n,}    重复n次或更多次</li><li>{n,m}    重复n到m次</li></ul></li><li>懒惰限定符<ul><li>“*?”   重复任意次，但尽可能少重复 </li><li>“+?”   重复1次或更多次，但尽可能少重复</li><li>“??”   重复0次或1次，但尽可能少重复</li><li>“{n,m}?”  重复n到m次，但尽可能少重复</li><li>“{n,}?”    重复n次以上，但尽可能少重复</li></ul></li></ul><h1 id="13、贪婪模式和非贪婪模式"><a href="#13、贪婪模式和非贪婪模式" class="headerlink" title="13、贪婪模式和非贪婪模式"></a>13、贪婪模式和非贪婪模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str = &apos;123456789&apos;;</div><div class="line">str.replace(/\d&#123;1,3&#125;/g,&apos;A&apos;);  ==&gt; AAA</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str = &apos;123456789&apos;;</div><div class="line">console.log(str.replace(/\d&#123;1,3&#125;?/g,&apos;A&apos;)) ==&gt; AAAAAAAAA</div></pre></td></tr></table></figure><h1 id="14、分组、反向引用、忽略分组"><a href="#14、分组、反向引用、忽略分组" class="headerlink" title="14、分组、反向引用、忽略分组"></a>14、分组、反向引用、忽略分组</h1><ul><li><p>使用括号()可以达到分组的功能，使量词作用于分组而不是作用于它最近的字符作用是分组引用和改变优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2018-01-03 ==&gt; 2018年01月03日</div><div class="line">var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">&apos;2018-01-03&apos;.replace(reg,&apos;$1年$2月$3日&apos;) ==&gt; 2018年01月03日</div></pre></td></tr></table></figure></li><li><p>后向引用<br>使用小括号指定一个子表达式后，匹配这个子表达式的文本可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p></li><li>忽略分组，匹配分组的文本但是不捕获也不给此分组分配组号，只需要在分组前面加上?：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;(?:exp)&quot;  匹配exp,不捕获匹配的文本，也不给此分组分配组号</div><div class="line">var reg = /(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">&apos;2018-01-03&apos;.replace(reg,&apos;$1,$2,$3&apos;) ==&gt; 01,03,$3</div></pre></td></tr></table></figure></li></ul><h1 id="15、前瞻后顾"><a href="#15、前瞻后顾" class="headerlink" title="15、前瞻后顾"></a>15、前瞻后顾</h1><ul><li>正则表达式从文本头部向尾部开始解析，文本尾部方向，称为‘前’。</li><li>前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反。（javascript在语法上不支持后顾）<br>*(?=X )</li></ul><p>零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。也就是说要使此零宽度断言起到我们想要的效果的话，就必须把这个非捕获组放在整个表达式的右侧。例如，/w+(?=/d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = /\w(?=\d)/g;</div><div class="line">&apos;a2b3&apos;.replace(reg,&apos;X&apos;); ==&gt; X2X3</div></pre></td></tr></table></figure></p><p>*(?!X)</p><p>零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，/w+(?!/d) 与后不跟数字的单词匹配，而不与该数字匹配 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = /\w(?!\d)/g;</div><div class="line">&apos;a2b3cd&apos;.replace(reg,&apos;X&apos;); ==&gt; aXbXXX</div></pre></td></tr></table></figure></p><p>*(?&lt;=X)</p><p>零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?&lt;=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。</p><p>*(?&lt;!X)</p><p>零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?&lt;!19)99 与不跟在 19 后面的 99 的实例匹配</p><p>*(?#comment)    </p><p>注释这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p><h1 id="16、正则和字符串方法"><a href="#16、正则和字符串方法" class="headerlink" title="16、正则和字符串方法"></a>16、正则和字符串方法</h1><h1 id="正则的捕获-exec"><a href="#正则的捕获-exec" class="headerlink" title="正则的捕获 exec"></a>正则的捕获 exec</h1><ul><li>lastIndex:是正则每一次捕获在字符串中开始查找的位置，默认的值是0(上次一次查找的结束位置)</li><li>原理：加了全局修饰符g,正则每一次捕获结束后,我们的lastIndex的值都变为了最新的值,下一次捕获从最新的位置开始查找,这样就可以把所有需要捕获的内容都获取到了</li><li><p>常见方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">var reg = /\d+/g;</div><div class="line">var str = &quot;zhu2015an2016zhu2017&quot;;</div><div class="line">console.log(reg.lastIndex);//-&gt;0</div><div class="line"></div><div class="line">console.log(reg.exec(str));//-&gt;[&quot;2015&quot;, index: 3, input: &quot;zhu2015an2016zhu2017&quot;]</div><div class="line">console.log(reg.lastIndex);//-&gt;7</div><div class="line"></div><div class="line">console.log(reg.exec(str));//-&gt;[&quot;2016&quot;, index: 9, input: &quot;zhu2015an2016zhu2017&quot;]</div><div class="line">console.log(reg.lastIndex);//-&gt;13</div><div class="line"></div><div class="line">console.log(reg.exec(str));//-&gt;[&quot;2017&quot;, index: 16, input: &quot;zhu2015an2016zhu2017&quot;]</div><div class="line">console.log(reg.lastIndex);//20</div><div class="line"></div><div class="line">   var str1=&quot;asdsda&quot;;</div><div class="line">   var str2=&quot;dddbat&quot;;</div><div class="line">   var str3=&quot;dddbat&quot;;</div><div class="line"></div><div class="line">   //匹配字符串中所有&quot;at&quot;的实例</div><div class="line">   var pattern1 = /at/g;</div><div class="line">   console.log(pattern1.test(str1));//false</div><div class="line">   console.log(pattern1.test(str2));//true</div><div class="line">   console.log(pattern1.test(str3));//false  【这里是falst】</div><div class="line"></div><div class="line">   //匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写</div><div class="line">   var pattern2 = /[bc]at/i;</div><div class="line"></div><div class="line">   //匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写</div><div class="line">   var pattern3 = /.at/gi;</div><div class="line"></div><div class="line">   var reg1=/\d+/g,</div><div class="line">       str1=&quot;zhu2015an2016zhu2017&quot;,</div><div class="line">       ary=[],</div><div class="line">       res=reg1.exec(str1);s</div><div class="line">   </div><div class="line">   while(res)&#123;</div><div class="line">       ary.push(res[0]);</div><div class="line">       res=reg1.exec(str1);</div><div class="line">   &#125;</div><div class="line">   console.log(ary);//[&quot;2015&quot;, &quot;2016&quot;, &quot;2017&quot;]</div></pre></td></tr></table></figure></li><li><p>字符串中的match方法-&gt;把所有和正则匹配的字符都获取到</p><p>  var reg = /\d+?/g;<br>  var str = “zhu2015an2016zhu2017”;<br>  var ary = str.match(reg);<br>  console.log(ary);</p></li><li><p>match比exec更加的简便一些,但是match中在分组捕获的情况下,match只能捕获到大正则匹配的内容,而对于小正则捕获的内容是无法获取的;</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/12/24/RegExp/images/regexp.jpg&quot; alt=&quot;regexp&quot; title=&quot;regexp&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;正则表达式的基础&quot;&gt;&lt;a href=&quot;#正则表达式的基础&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>singleton</title>
    <link href="/shmilyvidian.site/2017/12/03/singleton/"/>
    <id>/shmilyvidian.site/2017/12/03/singleton/</id>
    <published>2017-12-03T06:53:33.000Z</published>
    <updated>2018-01-12T14:57:34.499Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/12/03/singleton/images/single.jpg" alt=""></p><h1 id="JAVASCRIPT设计模式之单例模式"><a href="#JAVASCRIPT设计模式之单例模式" class="headerlink" title="JAVASCRIPT设计模式之单例模式"></a>JAVASCRIPT设计模式之单例模式</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><pre><code>单例模式又称单体模式，是只允许实例化一次的对象类，并提供一个全局的访问点。合适应用javascript设计模式可以使我们的代码逻辑更加清晰，并且更加易于维护和重构我们经常在为一个需求定义很多基础方法，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getId (id) &#123;</div><div class="line">    return document.getElementById(id)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getCss (id, key, value) &#123;</div><div class="line">    getId(id).style[key] = value</div><div class="line">&#125;</div><div class="line"></div><div class="line">function on (id, type, fn) &#123;</div><div class="line">    getId(id)[&apos;on&apos; + type] = fn</div><div class="line">&#125;</div></pre></td></tr></table></figure>这样做明显不妥的就是命名冲突， 日后其他同事为新需求增加代码或者引入某个库，导致当前的方法被冲突重写了的问题。这种时候单例模式就可以大显身手了。</code></pre><h2 id="单例模式管理命名空间"><a href="#单例模式管理命名空间" class="headerlink" title="单例模式管理命名空间"></a>单例模式管理命名空间</h2><pre><code>单例模式为我们提供一个命名空间，让我们的代码更易维护和重构，解决变量冲突问题。比如jQuery库为我们提供了一个命名空间jQuery。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Li = &#123;</div><div class="line">    getId: function (id)&#123;</div><div class="line">        return document.getElementById(id)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getCss: function (id, key, value)&#123;</div><div class="line">        getId(id).style[key] = value</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    on: function on(id, type, fn)&#123;</div><div class="line">        getId(id)[&apos;on&apos; + type] = fn</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>这样虽然可能存在人家也命名了一个Li的对象导致冲突，但是这种冲突毕竟比概率比之前就低很多了，只要大家约定俗成遵守规范就可以避免。</code></pre><h2 id="模块和使用"><a href="#模块和使用" class="headerlink" title="模块和使用"></a>模块和使用</h2><pre><code>单例模式通过定义命名空间可以避免变量冲突之外还可以模块化你的代码。比如我新建dom对象放入Li中，关于dom的方法我就放入dom模块，工具方法新建一个对象util放入Li中。之后调用各模块的方法就可以这样。- Li.dom.addClass- Li.util.trim每次你新建类似的方法你就知道放入对应的模块，调用的时候从对应的模块取出即可，映射关系分明，模块分明的效果一目了然。</code></pre><h2 id="单例模式实现静态变量"><a href="#单例模式实现静态变量" class="headerlink" title="单例模式实现静态变量"></a>单例模式实现静态变量</h2><pre><code>单例模式在对象里面创建对象私有变量，只暴露出取出私有变量的方法就可以实现无法修改的静态变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Person = &#123;</div><div class="line">    var characters = &#123;</div><div class="line">        name: &apos;li&apos;</div><div class="line">        sex：&apos;male&apos;,</div><div class="line">        age: 23</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">        get: function (name) &#123;</div><div class="line">            return characters[name]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>现在只能使用但不能修改内部定义的变量了。</code></pre><h2 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h2><pre><code>单例模式存在一种延迟创建即在创建实例的时候才会执行方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var Lazy = (function () &#123;</div><div class="line">    var _instance = null;</div><div class="line"></div><div class="line">    function Single () &#123;</div><div class="line">        return &#123;</div><div class="line">            method: function () &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return function () &#123;</div><div class="line">        if (!_instance) &#123;</div><div class="line">            _instance = Single();</div><div class="line">        &#125; else &#123;</div><div class="line">            return _instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></code></pre><h2 id="单例模式的场景"><a href="#单例模式的场景" class="headerlink" title="单例模式的场景"></a>单例模式的场景</h2><pre><code>1 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。</code></pre><p>　  2 控制资源的情况下，方便资源之间的互相通信。如线程池等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/12/03/singleton/images/single.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;JAVASCRIPT设计模式之单例模式&quot;&gt;&lt;a href=&quot;#JAVASCRIPT设计模式之单例模式&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JAVASCRIPT  分类" scheme="/shmilyvidian.site/categories/JAVASCRIPT-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx简单配置</title>
    <link href="/shmilyvidian.site/2017/12/02/nginx/"/>
    <id>/shmilyvidian.site/2017/12/02/nginx/</id>
    <published>2017-12-02T15:37:02.000Z</published>
    <updated>2017-12-03T03:39:47.104Z</updated>
    
    <content type="html"><![CDATA[<p>nginx基本就分为以下几块：</p><h2 id="nginx配置文件主要分为六个区域："><a href="#nginx配置文件主要分为六个区域：" class="headerlink" title="nginx配置文件主要分为六个区域："></a>nginx配置文件主要分为六个区域：</h2><h3 id="main-全局设置-、events-nginx工作模式-、http-http设置-、"><a href="#main-全局设置-、events-nginx工作模式-、http-http设置-、" class="headerlink" title="main(全局设置)、events(nginx工作模式)、http(http设置)、"></a>main(全局设置)、events(nginx工作模式)、http(http设置)、</h3><p>sever(主机设置)、location(URL匹配)、upstream(负载均衡服务器设置)。</p><h2 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h2><p>1 下面时一个main区域，他是一个全局的设置：</p><p>user nobody nobody;<br>worker_processes 2;<br>error_log  /usr/local/var/log/nginx/error.log  notice;<br>pid        /usr/local/var/run/nginx/nginx.pid;<br>worker_rlimit_nofile 1024;<br>user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。</p><p>2 worker_processes来指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了，如果是多核CPU，建议指定和CPU的数量一样的进程数即可。我这里写2，那么就会开启2个子进程，总共3个进程。</p><p>3 error_log用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</p><p>4 pid用来指定进程id的存储文件位置。</p><p>5 worker_rlimit_nofile用于指定一个nginx进程可以打开的最多文件描述符数目，这里是65535，需要使用命令“ulimit -n 65535”来设置。</p><h2 id="events-模块"><a href="#events-模块" class="headerlink" title="events 模块"></a>events 模块</h2><h3 id="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："><a href="#events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：" class="headerlink" title="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："></a>events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：</h3><p>1 events {<br>    use kqueue; #mac平台<br>    worker_connections  1024;<br>}<br>2 use用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。</p><p>3 worker_connections用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_clients=worker_processes<em>worker_connections，在作为反向代理时，Max_clients变为：Max_clients = worker_processes </em> worker_connections/4。<br>进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</p><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><h3 id="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"><a href="#http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。" class="headerlink" title="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"></a>http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。</h3><p>1 http{<br>    include       mime.types;<br>    default_type  application/octet-stream;<br>    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                      ‘$status $body_bytes_sent “$http_referer” ‘<br>                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;<br>    access_log  /usr/local/var/log/nginx/access.log  main;<br>    sendfile        on;<br>    tcp_nopush      on;<br>    tcp_nodelay     on;<br>    keepalive_timeout  10;</p><pre><code>#gzip  on;upstream myproject {    .....}server {    ....}</code></pre><p>}<br>2 下面详细介绍下这段代码中每个配置选项的含义。<br>include 来用设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</p><p>default_type设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp 的locate 环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载了。</p><p>log_format用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</p><p>main的类型日志如下：也可以增删部分参数。</p><p>127.0.0.1 - - [21/Apr/2015:18:09:54 +0800] “GET /index.php HTTP/1.1” 200 87151 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36”<br>access_log 用来纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</p><p>sendfile参数用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</p><p>keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p><p>还有很多各种配置，以后等用到来再说。</p><h2 id="server-模块"><a href="#server-模块" class="headerlink" title="server 模块"></a>server 模块</h2><h3 id="sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"><a href="#sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。" class="headerlink" title="sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"></a>sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。</h3><p>1 server {<br>        listen       8080;<br>        server_name  localhost 192.168.12.10 www.yangyi.com;</p><pre><code># 全局定义，如果都是这一个目录，这样定义最简单。root   /Users/yangyi/www;index  index.php index.html index.htm; charset utf-8;access_log  usr/local/var/log/host.access.log  main;aerror_log  usr/local/var/log/host.error.log  error;....</code></pre><p>}<br>2 server标志定义虚拟主机开始。<br>3 listen用于指定虚拟主机的服务端口。<br>4 server_name用来指定IP地址或者域名，多个域名之间用空格分开。<br>5 root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。<br>6 index 全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。<br>7 charset用于设置网页的默认编码格式。<br>8 access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p><h2 id="location-模块"><a href="#location-模块" class="headerlink" title="location 模块"></a>location 模块</h2><h3 id="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"><a href="#location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。" class="headerlink" title="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"></a>location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。</h3><p>location 根据它字面意思就知道是来定位的，定位URL，解析URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。像我们的php环境搭建就是用到了它。</p><p>1 我们先来看这个，设定默认首页和虚拟机目录。</p><p>ocation / {<br>            root   /Users/yangyi/www;<br>            index  index.php index.html index.htm;<br>        }<br>2 location /表示匹配访问根目录。</p><p>3 root指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。</p><p>index用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</p><p>location 还有一种方式就是正则匹配，开启正则匹配这样：location ~。后面加个~。</p><p>下面这个例子是运用正则匹配来链接php。我们之前搭建环境也是这样做：</p><p>location ~ .php$ {<br>            root           /Users/yangyi/www;<br>            fastcgi_pass   127.0.0.1:9000;<br>            fastcgi_index  index.php;<br>            include        fastcgi.conf;<br>        }<br>.php$ 熟悉正则的我们直到，这是匹配.php结尾的URL，用来解析php文件。里面的root也是一样，用来表示虚拟主机的根目录。<br>fast_pass链接的是php-fpm 的地址，之前我们也搭建过。其他几个参数我们以后再说。</p><h2 id="upstram-模块"><a href="#upstram-模块" class="headerlink" title="upstram 模块"></a>upstram 模块</h2><h3 id="upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"><a href="#upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。" class="headerlink" title="upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"></a>upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。</h3><p>upstream iyangyi.com{<br>    ip_hash;<br>    server 192.168.12.1:80;<br>    server 192.168.12.2:80 down;<br>    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;<br>    server 192.168.12.4:8080;<br>}<br>在上面的例子中，通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</p><p>里面是ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。紧接着就是各种服务器了。用server关键字表识，后面接ip。</p><p>Nginx的负载均衡模块目前支持4种调度算法:</p><p>1 weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。<br>2 ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。<br>fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。<br>3 url_hash。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。<br>4 在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p><p>down，表示当前的server暂时不参与负载均衡。<br>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。<br>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。<br>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。<br>注意 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx基本就分为以下几块：&lt;/p&gt;
&lt;h2 id=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;a href=&quot;#nginx配置文件主要分为六个区域：&quot; class=&quot;headerlink&quot; title=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;/a&gt;nginx配置文件
      
    
    </summary>
    
      <category term="HTTP  分类" scheme="/shmilyvidian.site/categories/HTTP-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>利用hexo+githubpage+阿里云搭建个人博客</title>
    <link href="/shmilyvidian.site/2017/11/05/hexo/"/>
    <id>/shmilyvidian.site/2017/11/05/hexo/</id>
    <published>2017-11-05T03:07:36.276Z</published>
    <updated>2017-12-03T03:40:08.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用hexo-githubpage-阿里云搭建个人博客"><a href="#利用hexo-githubpage-阿里云搭建个人博客" class="headerlink" title="利用hexo+githubpage+阿里云搭建个人博客"></a>利用hexo+githubpage+阿里云搭建个人博客</h1><hr><p>因为最近在想搞一个自己的博客,发现GitHub+Hexo是最好的一个选择了,折腾了很多，走了很多配置的坑, 发现网上的教程虽然有很多,但是自己一步步操作得形成自己的体系，毕竟自己的东西才是更有意义的，所以记录下来希望可以帮助其他人博客的搭建, 一是为了总结,二是为了让更多的人少走弯路,更快的搭建好自己的博客平台.<br><br><img src="/11/05/hexo/../images/timig.jpg" alt="hexo"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>–<br>默认你是github注册用户,电脑已安装node,git</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>–<br>Hexo是一个基于Node.js的快速简单的静态博客框架<br>    安装方法:npm install -g hexo</p><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>–<br>在你新建的博客文件夹中,一开始即当前文件夹为空的前提执行hexo init floder_name<br>然后cd floder_name执行npm i</p><h3 id="hexo基础命令"><a href="#hexo基础命令" class="headerlink" title="hexo基础命令"></a>hexo基础命令</h3><p>–<br>hexo clean<br>hexo g<br>hexo d<br>hexo server -p [prot]</p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>–<br>配置_config.yml文件</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>## Docs: http://hexo.io/docs/deployment.htmldeploy:    type: github    repository: https://github.com/用户名/用户名.github.io.git    branch: master</code></pre><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>–<br>阿里云购买域名域名解析两种方式<br>1.添加CNAME,活动记录填你github的ip地址   (ping username.github.io)<br>2.添加a,活动记录填你gitHub仓库地址</p><h3 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h3><p>– hexo官网主题选择你喜欢的主题后去往github地址下载下来放在不博客地址的themes文件夹中,然后在博客配置文件_config.yml更改theme: your_download_theme_name,其他如需配置根据主题提供者的文档修改即可</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.每次修改后执行了hexo d都会清除CNAME文件,解决方法你在github你的博客仓库setting手动添加custom domain,或者新建CNAME文件然后写入你的域名地址<br>2.hexo中文地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用hexo-githubpage-阿里云搭建个人博客&quot;&gt;&lt;a href=&quot;#利用hexo-githubpage-阿里云搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;利用hexo+githubpage+阿里云搭建个人博客&quot;&gt;&lt;/a&gt;利用hex
      
    
    </summary>
    
      <category term="ppt  分类" scheme="/shmilyvidian.site/categories/ppt-%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="标签1" scheme="/shmilyvidian.site/tags/%E6%A0%87%E7%AD%BE1/"/>
    
      <category term="标签2 ( 可选 )" scheme="/shmilyvidian.site/tags/%E6%A0%87%E7%AD%BE2-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
</feed>
