<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shmilyvidian</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/shmilyvidian.site/"/>
  <updated>2017-12-24T08:34:42.405Z</updated>
  <id>/shmilyvidian.site/</id>
  
  <author>
    <name>shmilyvidian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RegExp</title>
    <link href="/shmilyvidian.site/2017/12/24/RegExp/"/>
    <id>/shmilyvidian.site/2017/12/24/RegExp/</id>
    <published>2017-12-23T17:55:26.000Z</published>
    <updated>2017-12-24T08:34:42.405Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式的基础"><a href="#正则表达式的基础" class="headerlink" title="正则表达式的基础"></a>正则表达式的基础</h1><ul><li>起源</li><li>正则是什么</li><li>如何创建一个正则</li><li>如何学习正则</li><li>正则的转义</li><li>正则的组成</li><li>修饰符</li><li>元字符</li><li>字符串类</li><li>范围类</li><li>预定义类</li><li>边界</li><li>量词</li><li>贪婪模式</li><li>非贪婪模式</li><li>分组</li><li>反向引用</li><li>忽略分组</li><li>前瞻后顾</li><li>对象属性</li><li>正则方法</li><li><p>字符串方法</p><h1 id="1、正则是什么？"><a href="#1、正则是什么？" class="headerlink" title="1、正则是什么？"></a>1、正则是什么？</h1></li><li><p>起源：正则表达式的“祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。<br>1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为“神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为“正则集的代数”的表达式，因此采用“正则表达式”这个术语。<br>随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。<br>如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。</p></li><li>正则：它就是一个匹配规则，用来搜索和匹配的工具，记录文本的代码。</li></ul><h1 id="2、如何创建一个正则"><a href="#2、如何创建一个正则" class="headerlink" title="2、如何创建一个正则?"></a>2、如何创建一个正则?</h1><ul><li><p>字面量方式:</p><p>  var reg = /\d/;</p></li><li><p>构造函数方式:</p><p>  var reg = new RegExp(“”);</p></li></ul><p><strong>正则的两种创建方式是有区别的</strong></p><p>　　在字面量方式中,我们//之间包起来的所有的内容都是元字符,有的具有特殊的意义,大部分都是代表本身含义的普通的元字符</p><ul><li>1)字面量方式中出现的一切都是元字符,所以不能进行变量值的拼接,而实例创建的正则表达式可以使用变量；</li><li>2)字面量方式中直接写\d就可以,而在实例中需要把它转译 \d</li><li>3)要注意的是，传递给 RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给 RegExp 构造函数）。由于 RegExp 构造<br>函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。</li></ul><h1 id="3、如何学习正则"><a href="#3、如何学习正则" class="headerlink" title="3、如何学习正则?"></a>3、如何学习正则?</h1><ul><li>MDN文档</li><li>RegExp.prototype查看具体api</li><li><a href="https://github.com/javallone/regexper-static" target="_blank" rel="external">regexper</a> ‘正则测试工具’</li><li>多练多理解</li></ul><h1 id="4、正则转义"><a href="#4、正则转义" class="headerlink" title="4、正则转义"></a>4、正则转义</h1><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p><p>( [ { \ ^ $ | ) ? * + .]}</p><p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p><h1 id="5、正则表达式是由普通字符（例如字符a-z）以及特殊字符（称为元字符）组成的文字模式。"><a href="#5、正则表达式是由普通字符（例如字符a-z）以及特殊字符（称为元字符）组成的文字模式。" class="headerlink" title="5、正则表达式是由普通字符（例如字符a~z）以及特殊字符（称为元字符）组成的文字模式。"></a>5、正则表达式是由普通字符（例如字符a~z）以及特殊字符（称为元字符）组成的文字模式。</h1><h1 id="6、正则修饰符-默认都是false-可读不可写"><a href="#6、正则修饰符-默认都是false-可读不可写" class="headerlink" title="6、正则修饰符(默认都是false,可读不可写)"></a>6、正则修饰符(默认都是false,可读不可写)</h1><ul><li><p>1)i(ingore case)：大小写不敏感。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;Hello&apos;;</div><div class="line">var regexp1 = /hello/,regexp2 = /hello/i;</div><div class="line">regexp1.test(str) =&gt; false</div><div class="line">regexp2.test(str) =&gt; true</div></pre></td></tr></table></figure></li><li><p>2)g(global)：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;hello Elin&apos;;</div><div class="line">var regexp1 = /e/g,regexp2 = /e/ig;</div><div class="line">str.replace(regexp1,&apos;A&apos;); =&gt; &apos;hAllo Elin&apos;</div><div class="line">str.replace(regexp1,&apos;A&apos;); =&gt; &apos;hAllo Alin&apos;</div></pre></td></tr></table></figure></li><li><p>3)m(multiple)：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用，若不指定 m，则：^ 只在字符串的最开头，$ 只在字符串的最结尾；若指定 m，则：^ 在字符串每一行的开头，$ 在字符串每一行的结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    var a = `</div><div class="line">123</div><div class="line">abc</div><div class="line">456</div><div class="line">`;</div><div class="line">    a.match(/^\d+$/) =&gt; null</div><div class="line">    a.match(/^\d+$/m) =&gt; [&apos;123&apos;]</div><div class="line">    a.match(/^\d+$/gm) =&gt; [&apos;123&apos;,&apos;456&apos;]</div></pre></td></tr></table></figure></li></ul><h1 id="7、元字符"><a href="#7、元字符" class="headerlink" title="7、元字符"></a>7、元字符</h1><p>正则表达式由原义文本字符和元字符组成。<br>常用的元字符<br>| 代码        | 说明          | reg   |<br>| ————- |:————-:| —–:|<br>| .  | 匹配除换行符以外的任意字符 | [^\r\n] |<br>| \w | 匹配字母或数字或下划线或汉字      |   [a-zA-Z_0-9] |<br>| \s | 匹配任意的空白符      |    [ \f\n\r\t\v] |<br>| \d | 匹配数字             | [0-9]<br>| ^  | 匹配字符串的开始    |<br>| $  | 匹配字符串的结束</p><h1 id="正则的捕获-exec"><a href="#正则的捕获-exec" class="headerlink" title="正则的捕获 exec"></a>正则的捕获 exec</h1><p>每一次捕获的时候都是先进行默认的匹配,如果没有匹配成功的,捕获的结果是null;只有有匹配的内容我们才能捕获到;</p><ul><li>知识点一、正则捕获的内容格式</li><li>知识点一、正则捕获的特点</li><li>知识点一、字符串中的 <strong>match</strong> 方法-&gt;把所有和正则匹配的字符都获取到</li></ul><h1 id="知识点一、捕获的内容格式"><a href="#知识点一、捕获的内容格式" class="headerlink" title="知识点一、捕获的内容格式"></a>知识点一、捕获的内容格式</h1><ul><li>捕获到的内容是一个数组<ul><li>数组中的第一项是当前大正则捕获的内容</li><li>index:捕获内容在字符串中开始的索引位置</li><li>input:捕获的原始字符串</li></ul></li></ul><h1 id="知识点二、正则捕获的特点"><a href="#知识点二、正则捕获的特点" class="headerlink" title="知识点二、正则捕获的特点"></a>知识点二、正则捕获的特点</h1><blockquote><p>正则的匹配，是少餐多食，能少匹配次数就少匹配，每一次匹配，能匹配到多少数据就匹配多少数据；</p></blockquote><ul><li>1)懒惰性-&gt;每一次执行exec只捕获第一个匹配的内容，在不进行任何处理的情况下，在执行多次捕获，捕获的还是第一个匹配的内容</li></ul><blockquote><p>lastIndex:是正则每一次捕获在字符串中开始查找的位置，默认的值是0(上次一次查找的结束位置)</p></blockquote><pre><code>var reg = /\d+/;var str = &quot;zhu2015an2016&quot;;console.log(reg.lastIndex);//0var res = reg.exec(str);console.dir(res);//-&gt;[&quot;2015&quot;...]//我们第二次通过exec捕获的内容还是第一个&quot;2015&quot;console.log(reg.lastIndex);//0 说明我们第二次捕获的时候也是要从字符串索引0处开始查找res = reg.exec(str);console.dir(res);//-&gt;[&quot;2015&quot;...]</code></pre><ul><li>2)如何解决懒惰性? -&gt;在正则的末尾加一个修饰符”g”<ul><li>img分别代表的意义；</li><li>ignoreCase(i):忽略大小写匹配    表示不区分大小写（case-insensitive）模式，即在确定匹配项时忽略模式与字符串的大小写；</li><li>multiline(m):多行匹配；        表示多行（multiline）模式，即在到达一行文本末尾时还会继续查找下一行中是否存在与模<br>式匹配的项。</li><li>global(g):全局匹配；表示全局（global）模式，即模式将被应用于所有字符串，而非在发现第一个匹配项时立即停止</li></ul></li></ul><blockquote><p>原理：加了全局修饰符g,正则每一次捕获结束后,我们的lastIndex的值都变为了最新的值,下一次捕获从最新的位置开始查找,这样就可以把所有需要捕获的内容都获取到了</p></blockquote><pre><code>var reg = /\d+/g;var str = &quot;zhu2015an2016zhu2017&quot;;console.log(reg.lastIndex);//-&gt;0console.log(reg.exec(str));//-&gt;[&quot;2015&quot;, index: 3, input: &quot;zhu2015an2016zhu2017&quot;]console.log(reg.lastIndex);//-&gt;7console.log(reg.exec(str));//-&gt;[&quot;2016&quot;, index: 9, input: &quot;zhu2015an2016zhu2017&quot;]console.log(reg.lastIndex);//-&gt;13console.log(reg.exec(str));//-&gt;[&quot;2017&quot;, index: 16, input: &quot;zhu2015an2016zhu2017&quot;]console.log(reg.lastIndex);//20var str1=&quot;asdsda&quot;;var str2=&quot;dddbat&quot;;var str3=&quot;dddbat&quot;;//匹配字符串中所有&quot;at&quot;的实例var pattern1 = /at/g;console.log(pattern1.test(str1));//falseconsole.log(pattern1.test(str2));//trueconsole.log(pattern1.test(str3));//false  【这里是falst】//匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写var pattern2 = /[bc]at/i;//匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写var pattern3 = /.at/gi;</code></pre><ul><li><p>3)自己编写程序获取正则捕获的所有的内容（一定不要忘记加g）</p><pre><code>var reg1=/\d+/g,    str1=&quot;zhu2015an2016zhu2017&quot;,    ary=[],    res=reg1.exec(str1);swhile(res){    ary.push(res[0]);    res=reg1.exec(str1);}console.log(ary);//[&quot;2015&quot;, &quot;2016&quot;, &quot;2017&quot;]</code></pre></li></ul><ul><li><p>4)贪婪性  正则的每一次捕获都是按照匹配最长的结果捕获的,例如:2符合正则 2015也符合正则,我们默认捕获的是2015</p><pre><code>var reg = /\d+/g;//-&gt;出现一到多个0-9之间的数字var str = &quot;zhu2015an2016zhu2017&quot;;console.log(reg.exec(str));//-&gt;[&quot;2015&quot;...]</code></pre></li><li><p>5)如何解决正则的贪婪性 -&gt;在量词元字符后面添加一个?即可</p><ul><li>?在正则中有很多的作用:</li><li>放在一个普通的元字符后面代表出现0-1次 /\d?/ -&gt;数字可能出现也可能不出现</li><li><p>放在一个量词的元字符后面是取消捕获时候的贪婪性</p><pre><code>var reg = /\d+?/g;var str = &quot;zhu2015an2016zhu2017&quot;;console.log(reg.exec(str));//-&gt;[&quot;2&quot;...]var ary = [],    res = reg.exec(str);while (res) {       ary.push(res[0]);       res = reg.exec(str);    }console.log(ary);//[&quot;0&quot;, &quot;1&quot;, &quot;5&quot;, &quot;2&quot;, &quot;0&quot;, &quot;1&quot;, &quot;6&quot;, &quot;2&quot;, &quot;0&quot;, &quot;1&quot;, &quot;7&quot;]</code></pre></li></ul></li></ul><h1 id="知识点三、字符串中的match方法-gt-把所有和正则匹配的字符都获取到"><a href="#知识点三、字符串中的match方法-gt-把所有和正则匹配的字符都获取到" class="headerlink" title="知识点三、字符串中的match方法-&gt;把所有和正则匹配的字符都获取到"></a>知识点三、字符串中的match方法-&gt;把所有和正则匹配的字符都获取到</h1><pre><code>var reg = /\d+?/g;var str = &quot;zhu2015an2016zhu2017&quot;;var ary = str.match(reg);console.log(ary);</code></pre><p><strong>match的缺点</strong>：虽然在当前的情况下match比我们的exec更加的简便一些,但是match中存在一些自己处理不了的问题:在分组捕获的情况下,match只能捕获到大正则匹配的内容,而对于小正则捕获的内容是无法获取的;</p><h1 id="分组捕获"><a href="#分组捕获" class="headerlink" title="分组捕获"></a>分组捕获</h1><h1 id="正则分组："><a href="#正则分组：" class="headerlink" title="正则分组："></a>正则分组：</h1><ul><li>1、改变优先级</li><li>2、分组引用</li></ul><blockquote><p>\2代表和第二个分组出现一模一样的内容；\1和第一个分组出现一模一样的内容；</p></blockquote><p>一模一样:和对应的分组中的内容的值都要一样</p><pre><code>var reg = /^(\w)\1(\w)\2$/;console.log(reg.test(&quot;zzhh&quot;));//-&gt;true,zz相同，hh相同console.log(reg.test(&quot;zzh_&quot;));//-&gt;false,zz相同，h_不相同console.log(reg.exec(&quot;zzhh&quot;));//-&gt;[&quot;zzhh&quot;, &quot;z&quot;, &quot;h&quot;, index: 0, input: &quot;zzhh&quot;]console.log(reg.exec(&quot;0011&quot;));//-&gt;[&quot;0011&quot;, &quot;0&quot;, &quot;1&quot;, index: 0, input: &quot;0011&quot;]</code></pre><ul><li>3、分组捕获 -&gt;正则在捕获的时候,不仅仅把大正则匹配的内容捕获到,而且还可以把小分组匹配的内容捕获到<ul><li>(?:) 在分组中?:的意思是只匹配不捕获</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式的基础&quot;&gt;&lt;a href=&quot;#正则表达式的基础&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的基础&quot;&gt;&lt;/a&gt;正则表达式的基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;起源&lt;/li&gt;
&lt;li&gt;正则是什么&lt;/li&gt;
&lt;li&gt;如何创建一个正则&lt;/li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>singleton</title>
    <link href="/shmilyvidian.site/2017/12/03/singleton/"/>
    <id>/shmilyvidian.site/2017/12/03/singleton/</id>
    <published>2017-12-03T06:53:33.000Z</published>
    <updated>2017-12-03T07:39:16.123Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/12/03/singleton/images/single.jpg" alt=""></p><h1 id="JAVASCRIPT设计模式之单例模式"><a href="#JAVASCRIPT设计模式之单例模式" class="headerlink" title="JAVASCRIPT设计模式之单例模式"></a>JAVASCRIPT设计模式之单例模式</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><pre><code>单例模式又称单体模式，是只允许实例化一次的对象类，并提供一个全局的访问点。合适应用javascript设计模式可以使我们的代码逻辑更加清晰，并且更加易于维护和重构我们经常在为一个需求定义很多基础方法，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getId (id) &#123;</div><div class="line">    return document.getElementById(id)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getCss (id, key, value) &#123;</div><div class="line">    getId(id).style[key] = value</div><div class="line">&#125;</div><div class="line"></div><div class="line">function on (id, type, fn) &#123;</div><div class="line">    getId(id)[&apos;on&apos; + type] = fn</div><div class="line">&#125;</div></pre></td></tr></table></figure>这样做明显不妥的就是命名冲突， 日后其他同事为新需求增加代码或者引入某个库，导致当前的方法被冲突重写了的问题。这种时候单例模式就可以大显身手了。</code></pre><h2 id="单例模式管理命名空间"><a href="#单例模式管理命名空间" class="headerlink" title="单例模式管理命名空间"></a>单例模式管理命名空间</h2><pre><code>单例模式为我们提供一个命名空间，让我们的代码更易维护和重构，解决变量冲突问题。比如jQuery库为我们提供了一个命名空间jQuery。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Li = &#123;</div><div class="line">    getId: function (id)&#123;</div><div class="line">        return document.getElementById(id)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getCss: function (id, key, value)&#123;</div><div class="line">        getId(id).style[key] = value</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    on: function on(id, type, fn)&#123;</div><div class="line">        getId(id)[&apos;on&apos; + type] = fn</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>这样虽然可能存在人家也命名了一个Li的对象导致冲突，但是这种冲突毕竟比概率比之前就低很多了，只要大家约定俗成遵守规范就可以避免。</code></pre><h2 id="模块和使用"><a href="#模块和使用" class="headerlink" title="模块和使用"></a>模块和使用</h2><pre><code>单例模式通过定义命名空间可以避免变量冲突之外还可以模块化你的代码。比如我新建dom对象放入Li中，关于dom的方法我就放入dom模块，工具方法新建一个对象util放入Li中。之后调用各模块的方法就可以这样。- Li.dom.addClass- Li.util.trim每次你新建类似的方法你就知道放入对应的模块，调用的时候从对应的模块取出即可，映射关系分明，模块分明的效果一目了然。</code></pre><h2 id="单例模式实现静态变量"><a href="#单例模式实现静态变量" class="headerlink" title="单例模式实现静态变量"></a>单例模式实现静态变量</h2><pre><code>单例模式在对象里面创建对象私有变量，只暴露出取出私有变量的方法就可以实现无法修改的静态变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Person = &#123;</div><div class="line">    var characters = &#123;</div><div class="line">        name: &apos;li&apos;</div><div class="line">        sex：&apos;male&apos;,</div><div class="line">        age: 23</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">        get: function (name) &#123;</div><div class="line">            return characters[name]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>现在只能使用但不能修改内部定义的变量了。</code></pre><h2 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h2><pre><code>单例模式存在一种延迟创建即在创建实例的时候才会执行方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var Lazy = (function () &#123;</div><div class="line">    var _instance = null;</div><div class="line"></div><div class="line">    function Single () &#123;</div><div class="line">        return &#123;</div><div class="line">            method: function () &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return function () &#123;</div><div class="line">        if (!_instance) &#123;</div><div class="line">            _instance = Single();</div><div class="line">        &#125; else &#123;</div><div class="line">            return _instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></code></pre><h2 id="单例模式的场景"><a href="#单例模式的场景" class="headerlink" title="单例模式的场景"></a>单例模式的场景</h2><pre><code>1 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。</code></pre><p>　  2 控制资源的情况下，方便资源之间的互相通信。如线程池等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/12/03/singleton/images/single.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;JAVASCRIPT设计模式之单例模式&quot;&gt;&lt;a href=&quot;#JAVASCRIPT设计模式之单例模式&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JAVASCRIPT  分类" scheme="/shmilyvidian.site/categories/JAVASCRIPT-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx简单配置</title>
    <link href="/shmilyvidian.site/2017/12/02/nginx/"/>
    <id>/shmilyvidian.site/2017/12/02/nginx/</id>
    <published>2017-12-02T15:37:02.000Z</published>
    <updated>2017-12-03T03:39:47.104Z</updated>
    
    <content type="html"><![CDATA[<p>nginx基本就分为以下几块：</p><h2 id="nginx配置文件主要分为六个区域："><a href="#nginx配置文件主要分为六个区域：" class="headerlink" title="nginx配置文件主要分为六个区域："></a>nginx配置文件主要分为六个区域：</h2><h3 id="main-全局设置-、events-nginx工作模式-、http-http设置-、"><a href="#main-全局设置-、events-nginx工作模式-、http-http设置-、" class="headerlink" title="main(全局设置)、events(nginx工作模式)、http(http设置)、"></a>main(全局设置)、events(nginx工作模式)、http(http设置)、</h3><p>sever(主机设置)、location(URL匹配)、upstream(负载均衡服务器设置)。</p><h2 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h2><p>1 下面时一个main区域，他是一个全局的设置：</p><p>user nobody nobody;<br>worker_processes 2;<br>error_log  /usr/local/var/log/nginx/error.log  notice;<br>pid        /usr/local/var/run/nginx/nginx.pid;<br>worker_rlimit_nofile 1024;<br>user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。</p><p>2 worker_processes来指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了，如果是多核CPU，建议指定和CPU的数量一样的进程数即可。我这里写2，那么就会开启2个子进程，总共3个进程。</p><p>3 error_log用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</p><p>4 pid用来指定进程id的存储文件位置。</p><p>5 worker_rlimit_nofile用于指定一个nginx进程可以打开的最多文件描述符数目，这里是65535，需要使用命令“ulimit -n 65535”来设置。</p><h2 id="events-模块"><a href="#events-模块" class="headerlink" title="events 模块"></a>events 模块</h2><h3 id="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："><a href="#events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：" class="headerlink" title="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："></a>events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：</h3><p>1 events {<br>    use kqueue; #mac平台<br>    worker_connections  1024;<br>}<br>2 use用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。</p><p>3 worker_connections用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_clients=worker_processes<em>worker_connections，在作为反向代理时，Max_clients变为：Max_clients = worker_processes </em> worker_connections/4。<br>进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</p><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><h3 id="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"><a href="#http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。" class="headerlink" title="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"></a>http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。</h3><p>1 http{<br>    include       mime.types;<br>    default_type  application/octet-stream;<br>    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                      ‘$status $body_bytes_sent “$http_referer” ‘<br>                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;<br>    access_log  /usr/local/var/log/nginx/access.log  main;<br>    sendfile        on;<br>    tcp_nopush      on;<br>    tcp_nodelay     on;<br>    keepalive_timeout  10;</p><pre><code>#gzip  on;upstream myproject {    .....}server {    ....}</code></pre><p>}<br>2 下面详细介绍下这段代码中每个配置选项的含义。<br>include 来用设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</p><p>default_type设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp 的locate 环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载了。</p><p>log_format用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</p><p>main的类型日志如下：也可以增删部分参数。</p><p>127.0.0.1 - - [21/Apr/2015:18:09:54 +0800] “GET /index.php HTTP/1.1” 200 87151 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36”<br>access_log 用来纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</p><p>sendfile参数用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</p><p>keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p><p>还有很多各种配置，以后等用到来再说。</p><h2 id="server-模块"><a href="#server-模块" class="headerlink" title="server 模块"></a>server 模块</h2><h3 id="sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"><a href="#sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。" class="headerlink" title="sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"></a>sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。</h3><p>1 server {<br>        listen       8080;<br>        server_name  localhost 192.168.12.10 www.yangyi.com;</p><pre><code># 全局定义，如果都是这一个目录，这样定义最简单。root   /Users/yangyi/www;index  index.php index.html index.htm; charset utf-8;access_log  usr/local/var/log/host.access.log  main;aerror_log  usr/local/var/log/host.error.log  error;....</code></pre><p>}<br>2 server标志定义虚拟主机开始。<br>3 listen用于指定虚拟主机的服务端口。<br>4 server_name用来指定IP地址或者域名，多个域名之间用空格分开。<br>5 root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。<br>6 index 全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。<br>7 charset用于设置网页的默认编码格式。<br>8 access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p><h2 id="location-模块"><a href="#location-模块" class="headerlink" title="location 模块"></a>location 模块</h2><h3 id="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"><a href="#location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。" class="headerlink" title="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"></a>location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。</h3><p>location 根据它字面意思就知道是来定位的，定位URL，解析URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。像我们的php环境搭建就是用到了它。</p><p>1 我们先来看这个，设定默认首页和虚拟机目录。</p><p>ocation / {<br>            root   /Users/yangyi/www;<br>            index  index.php index.html index.htm;<br>        }<br>2 location /表示匹配访问根目录。</p><p>3 root指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。</p><p>index用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</p><p>location 还有一种方式就是正则匹配，开启正则匹配这样：location ~。后面加个~。</p><p>下面这个例子是运用正则匹配来链接php。我们之前搭建环境也是这样做：</p><p>location ~ .php$ {<br>            root           /Users/yangyi/www;<br>            fastcgi_pass   127.0.0.1:9000;<br>            fastcgi_index  index.php;<br>            include        fastcgi.conf;<br>        }<br>.php$ 熟悉正则的我们直到，这是匹配.php结尾的URL，用来解析php文件。里面的root也是一样，用来表示虚拟主机的根目录。<br>fast_pass链接的是php-fpm 的地址，之前我们也搭建过。其他几个参数我们以后再说。</p><h2 id="upstram-模块"><a href="#upstram-模块" class="headerlink" title="upstram 模块"></a>upstram 模块</h2><h3 id="upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"><a href="#upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。" class="headerlink" title="upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"></a>upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。</h3><p>upstream iyangyi.com{<br>    ip_hash;<br>    server 192.168.12.1:80;<br>    server 192.168.12.2:80 down;<br>    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;<br>    server 192.168.12.4:8080;<br>}<br>在上面的例子中，通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</p><p>里面是ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。紧接着就是各种服务器了。用server关键字表识，后面接ip。</p><p>Nginx的负载均衡模块目前支持4种调度算法:</p><p>1 weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。<br>2 ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。<br>fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。<br>3 url_hash。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。<br>4 在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p><p>down，表示当前的server暂时不参与负载均衡。<br>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。<br>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。<br>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。<br>注意 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx基本就分为以下几块：&lt;/p&gt;
&lt;h2 id=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;a href=&quot;#nginx配置文件主要分为六个区域：&quot; class=&quot;headerlink&quot; title=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;/a&gt;nginx配置文件
      
    
    </summary>
    
      <category term="HTTP  分类" scheme="/shmilyvidian.site/categories/HTTP-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>利用hexo+githubpage+阿里云搭建个人博客</title>
    <link href="/shmilyvidian.site/2017/11/05/hexo/"/>
    <id>/shmilyvidian.site/2017/11/05/hexo/</id>
    <published>2017-11-05T03:07:36.275Z</published>
    <updated>2017-12-03T03:40:08.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用hexo-githubpage-阿里云搭建个人博客"><a href="#利用hexo-githubpage-阿里云搭建个人博客" class="headerlink" title="利用hexo+githubpage+阿里云搭建个人博客"></a>利用hexo+githubpage+阿里云搭建个人博客</h1><hr><p>因为最近在想搞一个自己的博客,发现GitHub+Hexo是最好的一个选择了,折腾了很多，走了很多配置的坑, 发现网上的教程虽然有很多,但是自己一步步操作得形成自己的体系，毕竟自己的东西才是更有意义的，所以记录下来希望可以帮助其他人博客的搭建, 一是为了总结,二是为了让更多的人少走弯路,更快的搭建好自己的博客平台.<br><br><img src="/11/05/hexo/../images/timig.jpg" alt="hexo"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>–<br>默认你是github注册用户,电脑已安装node,git</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>–<br>Hexo是一个基于Node.js的快速简单的静态博客框架<br>    安装方法:npm install -g hexo</p><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>–<br>在你新建的博客文件夹中,一开始即当前文件夹为空的前提执行hexo init floder_name<br>然后cd floder_name执行npm i</p><h3 id="hexo基础命令"><a href="#hexo基础命令" class="headerlink" title="hexo基础命令"></a>hexo基础命令</h3><p>–<br>hexo clean<br>hexo g<br>hexo d<br>hexo server -p [prot]</p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>–<br>配置_config.yml文件</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>## Docs: http://hexo.io/docs/deployment.htmldeploy:    type: github    repository: https://github.com/用户名/用户名.github.io.git    branch: master</code></pre><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>–<br>阿里云购买域名域名解析两种方式<br>1.添加CNAME,活动记录填你github的ip地址   (ping username.github.io)<br>2.添加a,活动记录填你gitHub仓库地址</p><h3 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h3><p>– hexo官网主题选择你喜欢的主题后去往github地址下载下来放在不博客地址的themes文件夹中,然后在博客配置文件_config.yml更改theme: your_download_theme_name,其他如需配置根据主题提供者的文档修改即可</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.每次修改后执行了hexo d都会清除CNAME文件,解决方法你在github你的博客仓库setting手动添加custom domain,或者新建CNAME文件然后写入你的域名地址<br>2.hexo中文地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用hexo-githubpage-阿里云搭建个人博客&quot;&gt;&lt;a href=&quot;#利用hexo-githubpage-阿里云搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;利用hexo+githubpage+阿里云搭建个人博客&quot;&gt;&lt;/a&gt;利用hex
      
    
    </summary>
    
      <category term="ppt  分类" scheme="/shmilyvidian.site/categories/ppt-%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="标签1" scheme="/shmilyvidian.site/tags/%E6%A0%87%E7%AD%BE1/"/>
    
      <category term="标签2 ( 可选 )" scheme="/shmilyvidian.site/tags/%E6%A0%87%E7%AD%BE2-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
</feed>
