<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shmilyvidian</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/shmilyvidian.site/"/>
  <updated>2017-12-02T15:44:59.338Z</updated>
  <id>/shmilyvidian.site/</id>
  
  <author>
    <name>shmilyvidian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>nginx简单配置</title>
    <link href="/shmilyvidian.site/2017/12/02/nginx%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE/"/>
    <id>/shmilyvidian.site/2017/12/02/nginx简单配置/</id>
    <published>2017-12-02T15:37:02.000Z</published>
    <updated>2017-12-02T15:44:59.338Z</updated>
    
    <content type="html"><![CDATA[<p>nginx基本就分为以下几块：</p><h2 id="nginx配置文件主要分为六个区域："><a href="#nginx配置文件主要分为六个区域：" class="headerlink" title="nginx配置文件主要分为六个区域："></a>nginx配置文件主要分为六个区域：</h2><h3 id="main-全局设置-、events-nginx工作模式-、http-http设置-、"><a href="#main-全局设置-、events-nginx工作模式-、http-http设置-、" class="headerlink" title="main(全局设置)、events(nginx工作模式)、http(http设置)、"></a>main(全局设置)、events(nginx工作模式)、http(http设置)、</h3><p>sever(主机设置)、location(URL匹配)、upstream(负载均衡服务器设置)。</p><h2 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h2><p>1 下面时一个main区域，他是一个全局的设置：</p><p>user nobody nobody;<br>worker_processes 2;<br>error_log  /usr/local/var/log/nginx/error.log  notice;<br>pid        /usr/local/var/run/nginx/nginx.pid;<br>worker_rlimit_nofile 1024;<br>user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。</p><p>2 worker_processes来指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了，如果是多核CPU，建议指定和CPU的数量一样的进程数即可。我这里写2，那么就会开启2个子进程，总共3个进程。</p><p>3 error_log用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</p><p>4 pid用来指定进程id的存储文件位置。</p><p>5 worker_rlimit_nofile用于指定一个nginx进程可以打开的最多文件描述符数目，这里是65535，需要使用命令“ulimit -n 65535”来设置。</p><h2 id="events-模块"><a href="#events-模块" class="headerlink" title="events 模块"></a>events 模块</h2><h3 id="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："><a href="#events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：" class="headerlink" title="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："></a>events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：</h3><p>1 events {<br>    use kqueue; #mac平台<br>    worker_connections  1024;<br>}<br>2 use用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。</p><p>3 worker_connections用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_clients=worker_processes<em>worker_connections，在作为反向代理时，Max_clients变为：Max_clients = worker_processes </em> worker_connections/4。<br>进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</p><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><h3 id="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"><a href="#http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。" class="headerlink" title="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"></a>http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。</h3><p>1 http{<br>    include       mime.types;<br>    default_type  application/octet-stream;<br>    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                      ‘$status $body_bytes_sent “$http_referer” ‘<br>                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;<br>    access_log  /usr/local/var/log/nginx/access.log  main;<br>    sendfile        on;<br>    tcp_nopush      on;<br>    tcp_nodelay     on;<br>    keepalive_timeout  10;</p><pre><code>#gzip  on;upstream myproject {    .....}server {    ....}</code></pre><p>}<br>2 下面详细介绍下这段代码中每个配置选项的含义。<br>include 来用设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</p><p>default_type设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp 的locate 环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载了。</p><p>log_format用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</p><p>main的类型日志如下：也可以增删部分参数。</p><p>127.0.0.1 - - [21/Apr/2015:18:09:54 +0800] “GET /index.php HTTP/1.1” 200 87151 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36”<br>access_log 用来纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</p><p>sendfile参数用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</p><p>keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p><p>还有很多各种配置，以后等用到来再说。</p><h2 id="server-模块"><a href="#server-模块" class="headerlink" title="server 模块"></a>server 模块</h2><h3 id="sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"><a href="#sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。" class="headerlink" title="sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"></a>sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。</h3><p>1 server {<br>        listen       8080;<br>        server_name  localhost 192.168.12.10 www.yangyi.com;</p><pre><code># 全局定义，如果都是这一个目录，这样定义最简单。root   /Users/yangyi/www;index  index.php index.html index.htm; charset utf-8;access_log  usr/local/var/log/host.access.log  main;aerror_log  usr/local/var/log/host.error.log  error;....</code></pre><p>}<br>2 server标志定义虚拟主机开始。<br>3 listen用于指定虚拟主机的服务端口。<br>4 server_name用来指定IP地址或者域名，多个域名之间用空格分开。<br>5 root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。<br>6 index 全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。<br>7 charset用于设置网页的默认编码格式。<br>8 access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p><h2 id="location-模块"><a href="#location-模块" class="headerlink" title="location 模块"></a>location 模块</h2><h3 id="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"><a href="#location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。" class="headerlink" title="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"></a>location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。</h3><p>location 根据它字面意思就知道是来定位的，定位URL，解析URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。像我们的php环境搭建就是用到了它。</p><p>1 我们先来看这个，设定默认首页和虚拟机目录。</p><p>ocation / {<br>            root   /Users/yangyi/www;<br>            index  index.php index.html index.htm;<br>        }<br>2 location /表示匹配访问根目录。</p><p>3 root指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。</p><p>index用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</p><p>location 还有一种方式就是正则匹配，开启正则匹配这样：location ~。后面加个~。</p><p>下面这个例子是运用正则匹配来链接php。我们之前搭建环境也是这样做：</p><p>location ~ .php$ {<br>            root           /Users/yangyi/www;<br>            fastcgi_pass   127.0.0.1:9000;<br>            fastcgi_index  index.php;<br>            include        fastcgi.conf;<br>        }<br>.php$ 熟悉正则的我们直到，这是匹配.php结尾的URL，用来解析php文件。里面的root也是一样，用来表示虚拟主机的根目录。<br>fast_pass链接的是php-fpm 的地址，之前我们也搭建过。其他几个参数我们以后再说。</p><h2 id="upstram-模块"><a href="#upstram-模块" class="headerlink" title="upstram 模块"></a>upstram 模块</h2><h3 id="upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"><a href="#upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。" class="headerlink" title="upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"></a>upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。</h3><p>upstream iyangyi.com{<br>    ip_hash;<br>    server 192.168.12.1:80;<br>    server 192.168.12.2:80 down;<br>    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;<br>    server 192.168.12.4:8080;<br>}<br>在上面的例子中，通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</p><p>里面是ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。紧接着就是各种服务器了。用server关键字表识，后面接ip。</p><p>Nginx的负载均衡模块目前支持4种调度算法:</p><p>1 weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。<br>2 ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。<br>fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。<br>3 url_hash。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。<br>4 在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p><p>down，表示当前的server暂时不参与负载均衡。<br>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。<br>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。<br>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。<br>注意 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx基本就分为以下几块：&lt;/p&gt;
&lt;h2 id=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;a href=&quot;#nginx配置文件主要分为六个区域：&quot; class=&quot;headerlink&quot; title=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;/a&gt;nginx配置文件
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>利用hexo+githubpage+阿里云搭建个人博客</title>
    <link href="/shmilyvidian.site/2017/11/05/hello-world/"/>
    <id>/shmilyvidian.site/2017/11/05/hello-world/</id>
    <published>2017-11-05T03:07:36.275Z</published>
    <updated>2017-12-02T15:29:55.882Z</updated>
    
    <content type="html"><![CDATA[<p>因为最近在想搞一个自己的博客,发现GitHub+Hexo是最好的一个选择了,折腾了很多，走了很多配置的坑, 发现网上的教程虽然有很多,但是自己一步步操作得形成自己的体系，毕竟自己的东西才是更有意义的，所以记录下来希望可以帮助其他人博客的搭建, 一是为了总结,二是为了让更多的人少走弯路,更快的搭建好自己的博客平台.<br><br><img src="/11/05/hello-world/../images/timig.jpg" alt="hexo"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>–<br>默认你是github注册用户,电脑已安装node,git</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>–<br>Hexo是一个基于Node.js的快速简单的静态博客框架<br>    安装方法:npm install -g hexo</p><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>–<br>在你新建的博客文件夹中,一开始即当前文件夹为空的前提执行hexo init floder_name<br>然后cd floder_name执行npm i</p><h3 id="hexo基础命令"><a href="#hexo基础命令" class="headerlink" title="hexo基础命令"></a>hexo基础命令</h3><p>–<br>hexo clean<br>hexo g<br>hexo d<br>hexo server -p [prot]</p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>–<br>配置_config.yml文件</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>## Docs: http://hexo.io/docs/deployment.htmldeploy:    type: github    repository: https://github.com/用户名/用户名.github.io.git    branch: master</code></pre><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="###域名解析"></a>###域名解析</h2><p>阿里云购买域名域名解析两种方式<br>1.添加CNAME,活动记录填你github的ip地址   (ping username.github.io)<br>2.添加a,活动记录填你gitHub仓库地址</p><p>###主题更换<br>– hexo官网主题选择你喜欢的主题后去往github地址下载下来放在不博客地址的themes文件夹中,然后在博客配置文件_config.yml更改theme: your_download_theme_name,其他如需配置根据主题提供者的文档修改即可</p><p>###其他<br>1.每次修改后执行了hexo d都会清除CNAME文件,解决方法你在github你的博客仓库setting手动添加custom domain,或者新建CNAME文件然后写入你的域名地址<br>2.hexo中文地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;因为最近在想搞一个自己的博客,发现GitHub+Hexo是最好的一个选择了,折腾了很多，走了很多配置的坑, 发现网上的教程虽然有很多,但是自己一步步操作得形成自己的体系，毕竟自己的东西才是更有意义的，所以记录下来希望可以帮助其他人博客的搭建, 一是为了总结,二是为了让更多的
      
    
    </summary>
    
    
  </entry>
  
</feed>
