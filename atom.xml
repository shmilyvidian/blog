<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>shmilyvidian</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="/shmilyvidian.site/"/>
  <updated>2018-01-03T15:46:22.740Z</updated>
  <id>/shmilyvidian.site/</id>
  
  <author>
    <name>shmilyvidian</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RegExp</title>
    <link href="/shmilyvidian.site/2017/12/24/RegExp/"/>
    <id>/shmilyvidian.site/2017/12/24/RegExp/</id>
    <published>2017-12-23T17:55:26.000Z</published>
    <updated>2018-01-03T15:46:22.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式的基础"><a href="#正则表达式的基础" class="headerlink" title="正则表达式的基础"></a>正则表达式的基础</h1><ul><li>起源</li><li>正则是什么</li><li>如何创建一个正则</li><li>如何学习正则</li><li>正则的转义</li><li>正则的组成</li><li>修饰符</li><li>元字符</li><li>字符类</li><li>范围类</li><li>预定义类</li><li>边界</li><li>量词</li><li>贪婪模式</li><li>非贪婪模式</li><li>分组</li><li>反向引用</li><li>忽略分组</li><li>前瞻后顾</li><li>对象属性</li><li>正则方法</li><li><p>字符串方法</p><h1 id="1、正则是什么？"><a href="#1、正则是什么？" class="headerlink" title="1、正则是什么？"></a>1、正则是什么？</h1></li><li><p>起源：正则表达式的“祖先”可以一直上溯至对人类神经系统如何工作的早期研究。Warren McCulloch 和 Walter Pitts 这两位神经生理学家研究出一种数学方式来描述这些神经网络。<br>1956 年, 一位叫 Stephen Kleene 的数学家在 McCulloch 和 Pitts 早期工作的基础上，发表了一篇标题为“神经网事件的表示法”的论文，引入了正则表达式的概念。正则表达式就是用来描述他称为“正则集的代数”的表达式，因此采用“正则表达式”这个术语。<br>随后，发现可以将这一工作应用于使用 Ken Thompson 的计算搜索算法的一些早期研究，Ken Thompson 是 Unix 的主要发明人。正则表达式的第一个实用应用程序就是 Unix 中的 qed 编辑器。<br>如他们所说，剩下的就是众所周知的历史了。从那时起直至现在正则表达式都是基于文本的编辑器和搜索工具中的一个重要部分。</p></li><li>正则：它就是一个匹配规则，用来搜索和匹配的工具，记录文本的代码。</li></ul><h1 id="2、如何创建一个正则"><a href="#2、如何创建一个正则" class="headerlink" title="2、如何创建一个正则?"></a>2、如何创建一个正则?</h1><ul><li><p>字面量方式:</p><p>  var reg = /\d/;</p></li><li><p>构造函数方式:</p><p>  var reg = new RegExp(“”);</p></li></ul><p><strong>正则的两种创建方式是有区别的</strong></p><p>　　在字面量方式中,我们//之间包起来的所有的内容都是元字符,有的具有特殊的意义,大部分都是代表本身含义的普通的元字符</p><ul><li>1)字面量方式中出现的一切都是元字符,所以不能进行变量值的拼接,而实例创建的正则表达式可以使用变量；</li><li>2)字面量方式中直接写\d就可以,而在实例中需要把它转译 \d</li><li>3)要注意的是，传递给 RegExp 构造函数的两个参数都是字符串（不能把正则表达式字面量传递给 RegExp 构造函数）。由于 RegExp 构造<br>函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此。</li></ul><h1 id="3、如何学习正则"><a href="#3、如何学习正则" class="headerlink" title="3、如何学习正则?"></a>3、如何学习正则?</h1><ul><li>MDN文档</li><li>RegExp.prototype查看具体api</li><li><a href="https://github.com/javallone/regexper-static" target="_blank" rel="external">regexper</a> ‘正则测试工具’</li><li>多练多理解</li></ul><h1 id="4、正则转义"><a href="#4、正则转义" class="headerlink" title="4、正则转义"></a>4、正则转义</h1><p>与其他语言中的正则表达式类似，模式中使用的所有元字符都必须转义。正则表达式中的元字符包括：</p><p>( [ { \ ^ $ | ) ? * + .]}</p><p>这些元字符在正则表达式中都有一或多种特殊用途，因此如果想要匹配字符串中包含的这些字符，就必须对它们进行转义。</p><h1 id="5、正则表达式是由普通字符（例如字符a-z）以及特殊字符（称为元字符）组成的文字模式。"><a href="#5、正则表达式是由普通字符（例如字符a-z）以及特殊字符（称为元字符）组成的文字模式。" class="headerlink" title="5、正则表达式是由普通字符（例如字符a~z）以及特殊字符（称为元字符）组成的文字模式。"></a>5、正则表达式是由普通字符（例如字符a~z）以及特殊字符（称为元字符）组成的文字模式。</h1><h1 id="6、正则修饰符-默认都是false-可读不可写"><a href="#6、正则修饰符-默认都是false-可读不可写" class="headerlink" title="6、正则修饰符(默认都是false,可读不可写)"></a>6、正则修饰符(默认都是false,可读不可写)</h1><ul><li><p>1)i(ingore case)：大小写不敏感。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;Hello&apos;;</div><div class="line">var regexp1 = /hello/,regexp2 = /hello/i;</div><div class="line">regexp1.test(str) =&gt; false</div><div class="line">regexp2.test(str) =&gt; true</div></pre></td></tr></table></figure></li><li><p>2)g(global)：全局查找，对于一些特定的函数，将迭代完整的字符串，获得所有的匹配结果，而不仅仅在得到第一个匹配后就停止进行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">var str = &apos;hello Elin&apos;;</div><div class="line">var regexp1 = /e/g,regexp2 = /e/ig;</div><div class="line">str.replace(regexp1,&apos;A&apos;); =&gt; &apos;hAllo Elin&apos;</div><div class="line">str.replace(regexp1,&apos;A&apos;); =&gt; &apos;hAllo Alin&apos;</div></pre></td></tr></table></figure></li><li><p>3)m(multiple)：检测字符串中的换行符，主要是影响字符串开始标识符^和结束标识符$的使用，若不指定 m，则：^ 只在字符串的最开头，$ 只在字符串的最结尾；若指定 m，则：^ 在字符串每一行的开头，$ 在字符串每一行的结尾。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">    var a = `</div><div class="line">123</div><div class="line">abc</div><div class="line">456</div><div class="line">`;</div><div class="line">    a.match(/^\d+$/) =&gt; null</div><div class="line">    a.match(/^\d+$/m) =&gt; [&apos;123&apos;]</div><div class="line">    a.match(/^\d+$/gm) =&gt; [&apos;123&apos;,&apos;456&apos;]</div></pre></td></tr></table></figure></li></ul><h1 id="7、元字符"><a href="#7、元字符" class="headerlink" title="7、元字符"></a>7、元字符</h1><p>正则表达式由原义文本字符和元字符组成。<br>常用的元字符<br>| 代码        | 说明          | reg   |<br>| ————- |:————-:| —–:|<br>| .  | 匹配除换行符以外的任意字符 | [^\r\n] |<br>| \w | 匹配字母或数字或下划线或汉字      |   [a-zA-Z_0-9] |<br>| \s | 匹配任意的空白符      |    [ \f\n\r\t\v] |<br>| \d | 匹配数字             | [0-9]<br>| ^  | 匹配字符串的开始    |<br>| $  | 匹配字符串的结束</p><h1 id="8、字符类"><a href="#8、字符类" class="headerlink" title="8、字符类"></a>8、字符类</h1><p>元字符[]构建一个简单的类，此时的类是符合某些特征的对象。使用方括号[]包括一系列字符，能够匹配其中任意一个字符。</p><ul><li><p>[]里面以^开始表示非的意思，下面表示可以匹配到a b c之外的字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[^abc]</div></pre></td></tr></table></figure></li><li><p>字符类区间，你可以在字符类中使用连字符来表示一个字母或者数字的区间。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[\d]  ==  [0-9]</div><div class="line">[a-e] == [abcde]</div></pre></td></tr></table></figure></li></ul><h1 id="9、范围类"><a href="#9、范围类" class="headerlink" title="9、范围类"></a>9、范围类</h1><ul><li>在正则表示一类方法的需要用到字符类[],所谓类就是符合某些特征的对象，泛指而不是具体的某个字符。<br>例如上述例子中[abc]就是把字母a、b、c归为一类</li><li><p>中间使用连字符‘-’来连接两个字符表示从开始字符到结尾字符的任意字符。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[a-zA-z-0-9] == \w</div></pre></td></tr></table></figure></li><li><p>如果范围类中又想匹配到‘ - ’，但是我们知道-在[]内部表示范围，当我们需要匹配’-‘时可以直接加载在后面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[a-zA-z-0-9-]</div><div class="line">var string = &apos;a1b-2c3c-cee654A-DAD&apos;;</div><div class="line">   string = string.replace(/[a-zA-Z0-9-]/g, &apos;X&apos;);</div><div class="line">   console.log(string) ==&gt; &apos;XXXXXXXXXXXXXXXXXXXX&apos;</div></pre></td></tr></table></figure></li></ul><h1 id="10、预定义类"><a href="#10、预定义类" class="headerlink" title="10、预定义类"></a>10、预定义类</h1><ul><li>正则表达式提供了一些</li><li>常见预定义类：  <ul><li>字符 - 含义 </li><li>.   [^\r\n] 除了回车换行之外的所有字符 </li><li>\d  [0-9] 数字字符 digital</li><li>\D  [^0-9] 非数字字符 digital</li><li>\s  [\t\n\x0B\f\r] 空白字符 space</li><li>\S  [^\t\n\x0B\f\r] 非空白字符 space</li><li>\w  [a-zA-Z0-9_] 字母数字下划线 word</li><li>\W  非字母数字下划线 word<h1 id="11、边界"><a href="#11、边界" class="headerlink" title="11、边界"></a>11、边界</h1></li></ul></li><li>正则表达式提供了几种常见的边界匹配字符<ul><li>字符 - 含义 <ul><li>^    以什么开始</li><li>$    以什么结束</li><li>\b   单词边界</li><li>\B   非单词边界 </li></ul></li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">var string = &apos;this is a boy, this is a girl&apos;;</div><div class="line">   string = string.replace(/\bis\b/g, &apos;my&apos;)</div><div class="line">   console.log(string); ==&gt; this my a boy, this my a girl</div></pre></td></tr></table></figure><h1 id="12、-量词"><a href="#12、-量词" class="headerlink" title="12、 量词"></a>12、 量词</h1><ul><li>量词是正则中的限定符。<ul><li>‘*’    重复零次或更多次</li><li>‘+’    重复一次或更多次</li><li>‘?’    重复零次或一次</li><li>{n} 重复n次</li><li>{n,}    重复n次或更多次</li><li>{n,m}    重复n到m次</li></ul></li><li>懒惰限定符<ul><li>“*?”   重复任意次，但尽可能少重复 </li><li>“+?”   重复1次或更多次，但尽可能少重复</li><li>“??”   重复0次或1次，但尽可能少重复</li><li>“{n,m}?”  重复n到m次，但尽可能少重复</li><li>“{n,}?”    重复n次以上，但尽可能少重复</li></ul></li></ul><h1 id="13、贪婪模式和非贪婪模式"><a href="#13、贪婪模式和非贪婪模式" class="headerlink" title="13、贪婪模式和非贪婪模式"></a>13、贪婪模式和非贪婪模式</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str = &apos;123456789&apos;;</div><div class="line">str.replace(/\d&#123;1,3&#125;/g,&apos;A&apos;);  ==&gt; AAA</div></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var str = &apos;123456789&apos;;</div><div class="line">console.log(str.replace(/\d&#123;1,3&#125;?/g,&apos;A&apos;)) ==&gt; AAAAAAAAA</div></pre></td></tr></table></figure><h1 id="14、分组、反向引用、忽略分组"><a href="#14、分组、反向引用、忽略分组" class="headerlink" title="14、分组、反向引用、忽略分组"></a>14、分组、反向引用、忽略分组</h1><ul><li><p>使用括号()可以达到分组的功能，使量词作用于分组而不是作用于它最近的字符作用是分组引用和改变优先级。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">2018-01-03 ==&gt; 2018年01月03日</div><div class="line">var reg = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">&apos;2018-01-03&apos;.replace(reg,&apos;$1年$2月$3日&apos;) ==&gt; 2018年01月03日</div></pre></td></tr></table></figure></li><li><p>后向引用<br>使用小括号指定一个子表达式后，匹配这个子表达式的文本可以在表达式或其它程序中作进一步的处理。默认情况下，每个分组会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。</p></li><li>忽略分组，匹配分组的文本但是不捕获也不给此分组分配组号，只需要在分组前面加上?：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&quot;(?:exp)&quot;  匹配exp,不捕获匹配的文本，也不给此分组分配组号</div><div class="line">var reg = /(?:\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;</div><div class="line">&apos;2018-01-03&apos;.replace(reg,&apos;$1,$2,$3&apos;) ==&gt; 01,03,$3</div></pre></td></tr></table></figure></li></ul><h1 id="15、前瞻后顾"><a href="#15、前瞻后顾" class="headerlink" title="15、前瞻后顾"></a>15、前瞻后顾</h1><ul><li>正则表达式从文本头部向尾部开始解析，文本尾部方向，称为‘前’。</li><li>前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言，后顾/后瞻方向相反。（javascript在语法上不支持后顾）<br>*(?=X )</li></ul><p>零宽度正先行断言。仅当子表达式 X 在 此位置的右侧匹配时才继续匹配。也就是说要使此零宽度断言起到我们想要的效果的话，就必须把这个非捕获组放在整个表达式的右侧。例如，/w+(?=/d) 与后跟数字的单词匹配，而不与该数字匹配。此构造不会回溯。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = /\w(?=\d)/g;</div><div class="line">&apos;a2b3&apos;.replace(reg,&apos;X&apos;); ==&gt; X2X3</div></pre></td></tr></table></figure></p><p>*(?!X)</p><p>零宽度负先行断言。仅当子表达式 X 不在 此位置的右侧匹配时才继续匹配。例如，例如，/w+(?!/d) 与后不跟数字的单词匹配，而不与该数字匹配 。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">var reg = /\w(?!\d)/g;</div><div class="line">&apos;a2b3cd&apos;.replace(reg,&apos;X&apos;); ==&gt; aXbXXX</div></pre></td></tr></table></figure></p><p>*(?&lt;=X)</p><p>零宽度正后发断言。仅当子表达式 X 在 此位置的左侧匹配时才继续匹配。例如，(?&lt;=19)99 与跟在 19 后面的 99 的实例匹配。此构造不会回溯。</p><p>*(?&lt;!X)</p><p>零宽度负后发断言。仅当子表达式 X 不在此位置的左侧匹配时才继续匹配。例如，(?&lt;!19)99 与不跟在 19 后面的 99 的实例匹配</p><p>*(?#comment)    </p><p>注释这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读</p><h1 id="16、正则和字符串方法"><a href="#16、正则和字符串方法" class="headerlink" title="16、正则和字符串方法"></a>16、正则和字符串方法</h1><h1 id="正则的捕获-exec"><a href="#正则的捕获-exec" class="headerlink" title="正则的捕获 exec"></a>正则的捕获 exec</h1><ul><li>lastIndex:是正则每一次捕获在字符串中开始查找的位置，默认的值是0(上次一次查找的结束位置)</li><li>原理：加了全局修饰符g,正则每一次捕获结束后,我们的lastIndex的值都变为了最新的值,下一次捕获从最新的位置开始查找,这样就可以把所有需要捕获的内容都获取到了</li><li><p>常见方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line">var reg = /\d+/g;</div><div class="line">var str = &quot;zhu2015an2016zhu2017&quot;;</div><div class="line">console.log(reg.lastIndex);//-&gt;0</div><div class="line"></div><div class="line">console.log(reg.exec(str));//-&gt;[&quot;2015&quot;, index: 3, input: &quot;zhu2015an2016zhu2017&quot;]</div><div class="line">console.log(reg.lastIndex);//-&gt;7</div><div class="line"></div><div class="line">console.log(reg.exec(str));//-&gt;[&quot;2016&quot;, index: 9, input: &quot;zhu2015an2016zhu2017&quot;]</div><div class="line">console.log(reg.lastIndex);//-&gt;13</div><div class="line"></div><div class="line">console.log(reg.exec(str));//-&gt;[&quot;2017&quot;, index: 16, input: &quot;zhu2015an2016zhu2017&quot;]</div><div class="line">console.log(reg.lastIndex);//20</div><div class="line"></div><div class="line">    var str1=&quot;asdsda&quot;;</div><div class="line">    var str2=&quot;dddbat&quot;;</div><div class="line">    var str3=&quot;dddbat&quot;;</div><div class="line"></div><div class="line">    //匹配字符串中所有&quot;at&quot;的实例</div><div class="line">    var pattern1 = /at/g;</div><div class="line">    console.log(pattern1.test(str1));//false</div><div class="line">    console.log(pattern1.test(str2));//true</div><div class="line">    console.log(pattern1.test(str3));//false  【这里是falst】</div><div class="line"></div><div class="line">    //匹配第一个&quot;bat&quot;或&quot;cat&quot;，不区分大小写</div><div class="line">    var pattern2 = /[bc]at/i;</div><div class="line"></div><div class="line">    //匹配所有以&quot;at&quot;结尾的 3 个字符的组合，不区分大小写</div><div class="line">    var pattern3 = /.at/gi;</div><div class="line"></div><div class="line">    var reg1=/\d+/g,</div><div class="line">        str1=&quot;zhu2015an2016zhu2017&quot;,</div><div class="line">        ary=[],</div><div class="line">        res=reg1.exec(str1);s</div><div class="line">    </div><div class="line">    while(res)&#123;</div><div class="line">        ary.push(res[0]);</div><div class="line">        res=reg1.exec(str1);</div><div class="line">    &#125;</div><div class="line">    console.log(ary);//[&quot;2015&quot;, &quot;2016&quot;, &quot;2017&quot;]</div><div class="line"></div><div class="line"></div><div class="line">- 4)贪婪性  正则的每一次捕获都是按照匹配最长的结果捕获的,例如:2符合正则 2015也符合正则,我们默认捕获的是2015</div><div class="line"></div><div class="line">var reg = /\d+/g;//-&gt;出现一到多个0-9之间的数字</div><div class="line">var str = &quot;zhu2015an2016zhu2017&quot;;</div><div class="line">console.log(reg.exec(str));//-&gt;[&quot;2015&quot;...]</div></pre></td></tr></table></figure></li><li><p>字符串中的match方法-&gt;把所有和正则匹配的字符都获取到</p><p>  var reg = /\d+?/g;<br>  var str = “zhu2015an2016zhu2017”;<br>  var ary = str.match(reg);<br>  console.log(ary);</p></li><li><p>match的缺点：虽然在当前的情况下match比我们的exec更加的简便一些,但是match中存在一些自己处理不了的问题:在分组捕获的情况下,match只能捕获到大正则匹配的内容,而对于小正则捕获的内容是无法获取的;</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式的基础&quot;&gt;&lt;a href=&quot;#正则表达式的基础&quot; class=&quot;headerlink&quot; title=&quot;正则表达式的基础&quot;&gt;&lt;/a&gt;正则表达式的基础&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;起源&lt;/li&gt;
&lt;li&gt;正则是什么&lt;/li&gt;
&lt;li&gt;如何创建一个正则&lt;/li&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>singleton</title>
    <link href="/shmilyvidian.site/2017/12/03/singleton/"/>
    <id>/shmilyvidian.site/2017/12/03/singleton/</id>
    <published>2017-12-03T06:53:33.000Z</published>
    <updated>2017-12-03T07:39:16.123Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/12/03/singleton/images/single.jpg" alt=""></p><h1 id="JAVASCRIPT设计模式之单例模式"><a href="#JAVASCRIPT设计模式之单例模式" class="headerlink" title="JAVASCRIPT设计模式之单例模式"></a>JAVASCRIPT设计模式之单例模式</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><pre><code>单例模式又称单体模式，是只允许实例化一次的对象类，并提供一个全局的访问点。合适应用javascript设计模式可以使我们的代码逻辑更加清晰，并且更加易于维护和重构我们经常在为一个需求定义很多基础方法，如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">function getId (id) &#123;</div><div class="line">    return document.getElementById(id)</div><div class="line">&#125;</div><div class="line"></div><div class="line">function getCss (id, key, value) &#123;</div><div class="line">    getId(id).style[key] = value</div><div class="line">&#125;</div><div class="line"></div><div class="line">function on (id, type, fn) &#123;</div><div class="line">    getId(id)[&apos;on&apos; + type] = fn</div><div class="line">&#125;</div></pre></td></tr></table></figure>这样做明显不妥的就是命名冲突， 日后其他同事为新需求增加代码或者引入某个库，导致当前的方法被冲突重写了的问题。这种时候单例模式就可以大显身手了。</code></pre><h2 id="单例模式管理命名空间"><a href="#单例模式管理命名空间" class="headerlink" title="单例模式管理命名空间"></a>单例模式管理命名空间</h2><pre><code>单例模式为我们提供一个命名空间，让我们的代码更易维护和重构，解决变量冲突问题。比如jQuery库为我们提供了一个命名空间jQuery。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Li = &#123;</div><div class="line">    getId: function (id)&#123;</div><div class="line">        return document.getElementById(id)</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    getCss: function (id, key, value)&#123;</div><div class="line">        getId(id).style[key] = value</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    on: function on(id, type, fn)&#123;</div><div class="line">        getId(id)[&apos;on&apos; + type] = fn</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>这样虽然可能存在人家也命名了一个Li的对象导致冲突，但是这种冲突毕竟比概率比之前就低很多了，只要大家约定俗成遵守规范就可以避免。</code></pre><h2 id="模块和使用"><a href="#模块和使用" class="headerlink" title="模块和使用"></a>模块和使用</h2><pre><code>单例模式通过定义命名空间可以避免变量冲突之外还可以模块化你的代码。比如我新建dom对象放入Li中，关于dom的方法我就放入dom模块，工具方法新建一个对象util放入Li中。之后调用各模块的方法就可以这样。- Li.dom.addClass- Li.util.trim每次你新建类似的方法你就知道放入对应的模块，调用的时候从对应的模块取出即可，映射关系分明，模块分明的效果一目了然。</code></pre><h2 id="单例模式实现静态变量"><a href="#单例模式实现静态变量" class="headerlink" title="单例模式实现静态变量"></a>单例模式实现静态变量</h2><pre><code>单例模式在对象里面创建对象私有变量，只暴露出取出私有变量的方法就可以实现无法修改的静态变量。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">var Person = &#123;</div><div class="line">    var characters = &#123;</div><div class="line">        name: &apos;li&apos;</div><div class="line">        sex：&apos;male&apos;,</div><div class="line">        age: 23</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return &#123;</div><div class="line">        get: function (name) &#123;</div><div class="line">            return characters[name]</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>现在只能使用但不能修改内部定义的变量了。</code></pre><h2 id="惰性函数"><a href="#惰性函数" class="headerlink" title="惰性函数"></a>惰性函数</h2><pre><code>单例模式存在一种延迟创建即在创建实例的时候才会执行方法。<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">var Lazy = (function () &#123;</div><div class="line">    var _instance = null;</div><div class="line"></div><div class="line">    function Single () &#123;</div><div class="line">        return &#123;</div><div class="line">            method: function () &#123;&#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return function () &#123;</div><div class="line">        if (!_instance) &#123;</div><div class="line">            _instance = Single();</div><div class="line">        &#125; else &#123;</div><div class="line">            return _instance;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;)()</div></pre></td></tr></table></figure></code></pre><h2 id="单例模式的场景"><a href="#单例模式的场景" class="headerlink" title="单例模式的场景"></a>单例模式的场景</h2><pre><code>1 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。</code></pre><p>　  2 控制资源的情况下，方便资源之间的互相通信。如线程池等。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;/12/03/singleton/images/single.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;JAVASCRIPT设计模式之单例模式&quot;&gt;&lt;a href=&quot;#JAVASCRIPT设计模式之单例模式&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
      <category term="JAVASCRIPT  分类" scheme="/shmilyvidian.site/categories/JAVASCRIPT-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>nginx简单配置</title>
    <link href="/shmilyvidian.site/2017/12/02/nginx/"/>
    <id>/shmilyvidian.site/2017/12/02/nginx/</id>
    <published>2017-12-02T15:37:02.000Z</published>
    <updated>2017-12-03T03:39:47.104Z</updated>
    
    <content type="html"><![CDATA[<p>nginx基本就分为以下几块：</p><h2 id="nginx配置文件主要分为六个区域："><a href="#nginx配置文件主要分为六个区域：" class="headerlink" title="nginx配置文件主要分为六个区域："></a>nginx配置文件主要分为六个区域：</h2><h3 id="main-全局设置-、events-nginx工作模式-、http-http设置-、"><a href="#main-全局设置-、events-nginx工作模式-、http-http设置-、" class="headerlink" title="main(全局设置)、events(nginx工作模式)、http(http设置)、"></a>main(全局设置)、events(nginx工作模式)、http(http设置)、</h3><p>sever(主机设置)、location(URL匹配)、upstream(负载均衡服务器设置)。</p><h2 id="main模块"><a href="#main模块" class="headerlink" title="main模块"></a>main模块</h2><p>1 下面时一个main区域，他是一个全局的设置：</p><p>user nobody nobody;<br>worker_processes 2;<br>error_log  /usr/local/var/log/nginx/error.log  notice;<br>pid        /usr/local/var/run/nginx/nginx.pid;<br>worker_rlimit_nofile 1024;<br>user 来指定Nginx Worker进程运行用户以及用户组，默认由nobody账号运行。</p><p>2 worker_processes来指定了Nginx要开启的子进程数。每个Nginx进程平均耗费10M~12M内存。根据经验，一般指定1个进程就足够了，如果是多核CPU，建议指定和CPU的数量一样的进程数即可。我这里写2，那么就会开启2个子进程，总共3个进程。</p><p>3 error_log用来定义全局错误日志文件。日志输出级别有debug、info、notice、warn、error、crit可供选择，其中，debug输出日志最为最详细，而crit输出日志最少。</p><p>4 pid用来指定进程id的存储文件位置。</p><p>5 worker_rlimit_nofile用于指定一个nginx进程可以打开的最多文件描述符数目，这里是65535，需要使用命令“ulimit -n 65535”来设置。</p><h2 id="events-模块"><a href="#events-模块" class="headerlink" title="events 模块"></a>events 模块</h2><h3 id="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："><a href="#events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：" class="headerlink" title="events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样："></a>events模块来用指定nginx的工作模式和工作模式及连接数上限，一般是这样：</h3><p>1 events {<br>    use kqueue; #mac平台<br>    worker_connections  1024;<br>}<br>2 use用来指定Nginx的工作模式。Nginx支持的工作模式有select、poll、kqueue、epoll、rtsig和/dev/poll。其中select和poll都是标准的工作模式，kqueue和epoll是高效的工作模式，不同的是epoll用在Linux平台上，而kqueue用在BSD系统中，因为Mac基于BSD,所以Mac也得用这个模式，对于Linux系统，epoll工作模式是首选。</p><p>3 worker_connections用于定义Nginx每个进程的最大连接数，即接收前端的最大请求数，默认是1024。最大客户端连接数由worker_processes和worker_connections决定，即Max_clients=worker_processes<em>worker_connections，在作为反向代理时，Max_clients变为：Max_clients = worker_processes </em> worker_connections/4。<br>进程的最大连接数受Linux系统进程的最大打开文件数限制，在执行操作系统命令“ulimit -n 65536”后worker_connections的设置才能生效。</p><h2 id="http-模块"><a href="#http-模块" class="headerlink" title="http 模块"></a>http 模块</h2><h3 id="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"><a href="#http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。" class="headerlink" title="http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。"></a>http模块可以说是最核心的模块了，它负责HTTP服务器相关属性的配置，它里面的server和upstream子模块，至关重要，等到反向代理和负载均衡以及虚拟目录等会仔细说。</h3><p>1 http{<br>    include       mime.types;<br>    default_type  application/octet-stream;<br>    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>                      ‘$status $body_bytes_sent “$http_referer” ‘<br>                      ‘“$http_user_agent” “$http_x_forwarded_for”‘;<br>    access_log  /usr/local/var/log/nginx/access.log  main;<br>    sendfile        on;<br>    tcp_nopush      on;<br>    tcp_nodelay     on;<br>    keepalive_timeout  10;</p><pre><code>#gzip  on;upstream myproject {    .....}server {    ....}</code></pre><p>}<br>2 下面详细介绍下这段代码中每个配置选项的含义。<br>include 来用设定文件的mime类型,类型在配置文件目录下的mime.type文件定义，来告诉nginx来识别文件类型。</p><p>default_type设定了默认的类型为二进制流，也就是当文件类型未定义时使用这种方式，例如在没有配置asp 的locate 环境时，Nginx是不予解析的，此时，用浏览器访问asp文件就会出现下载了。</p><p>log_format用于设置日志的格式，和记录哪些参数，这里设置为main，刚好用于access_log来纪录这种类型。</p><p>main的类型日志如下：也可以增删部分参数。</p><p>127.0.0.1 - - [21/Apr/2015:18:09:54 +0800] “GET /index.php HTTP/1.1” 200 87151 “-“ “Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.76 Safari/537.36”<br>access_log 用来纪录每次的访问日志的文件地址，后面的main是日志的格式样式，对应于log_format的main。</p><p>sendfile参数用于开启高效文件传输模式。将tcp_nopush和tcp_nodelay两个指令设置为on用于防止网络阻塞。</p><p>keepalive_timeout设置客户端连接保持活动的超时时间。在超过这个时间之后，服务器会关闭该连接。</p><p>还有很多各种配置，以后等用到来再说。</p><h2 id="server-模块"><a href="#server-模块" class="headerlink" title="server 模块"></a>server 模块</h2><h3 id="sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"><a href="#sever-模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。" class="headerlink" title="sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。"></a>sever 模块是http的子模块，它用来定一个虚拟主机，下面是基本的配置。</h3><p>1 server {<br>        listen       8080;<br>        server_name  localhost 192.168.12.10 www.yangyi.com;</p><pre><code># 全局定义，如果都是这一个目录，这样定义最简单。root   /Users/yangyi/www;index  index.php index.html index.htm; charset utf-8;access_log  usr/local/var/log/host.access.log  main;aerror_log  usr/local/var/log/host.error.log  error;....</code></pre><p>}<br>2 server标志定义虚拟主机开始。<br>3 listen用于指定虚拟主机的服务端口。<br>4 server_name用来指定IP地址或者域名，多个域名之间用空格分开。<br>5 root 表示在这整个server虚拟主机内，全部的root web根目录。注意要和locate {}下面定义的区分开来。<br>6 index 全局定义访问的默认首页地址。注意要和locate {}下面定义的区分开来。<br>7 charset用于设置网页的默认编码格式。<br>8 access_log用来指定此虚拟主机的访问日志存放路径，最后的main用于指定访问日志的输出格式。</p><h2 id="location-模块"><a href="#location-模块" class="headerlink" title="location 模块"></a>location 模块</h2><h3 id="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"><a href="#location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。" class="headerlink" title="location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。"></a>location模块是nginx中用的最多的，也是最重要的模块了，什么负载均衡啊、反向代理啊、虚拟域名啊都与它相关。</h3><p>location 根据它字面意思就知道是来定位的，定位URL，解析URL，所以，它也提供了强大的正则匹配功能，也支持条件判断匹配，用户可以通过location指令实现Nginx对动、静态网页进行过滤处理。像我们的php环境搭建就是用到了它。</p><p>1 我们先来看这个，设定默认首页和虚拟机目录。</p><p>ocation / {<br>            root   /Users/yangyi/www;<br>            index  index.php index.html index.htm;<br>        }<br>2 location /表示匹配访问根目录。</p><p>3 root指令用于指定访问根目录时，虚拟主机的web目录，这个目录可以是相对路径（相对路径是相对于nginx的安装目录）。也可以是绝对路径。</p><p>index用于设定我们只输入域名后访问的默认首页地址，有个先后顺序：index.php index.html index.htm，如果没有开启目录浏览权限，又找不到这些默认首页，就会报403错误。</p><p>location 还有一种方式就是正则匹配，开启正则匹配这样：location ~。后面加个~。</p><p>下面这个例子是运用正则匹配来链接php。我们之前搭建环境也是这样做：</p><p>location ~ .php$ {<br>            root           /Users/yangyi/www;<br>            fastcgi_pass   127.0.0.1:9000;<br>            fastcgi_index  index.php;<br>            include        fastcgi.conf;<br>        }<br>.php$ 熟悉正则的我们直到，这是匹配.php结尾的URL，用来解析php文件。里面的root也是一样，用来表示虚拟主机的根目录。<br>fast_pass链接的是php-fpm 的地址，之前我们也搭建过。其他几个参数我们以后再说。</p><h2 id="upstram-模块"><a href="#upstram-模块" class="headerlink" title="upstram 模块"></a>upstram 模块</h2><h3 id="upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"><a href="#upstream-模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。" class="headerlink" title="upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。"></a>upstream 模块负债负载均衡模块，通过一个简单的调度算法来实现客户端IP到后端服务器的负载均衡。我先学习怎么用，具体的使用实例以后再说。</h3><p>upstream iyangyi.com{<br>    ip_hash;<br>    server 192.168.12.1:80;<br>    server 192.168.12.2:80 down;<br>    server 192.168.12.3:8080  max_fails=3  fail_timeout=20s;<br>    server 192.168.12.4:8080;<br>}<br>在上面的例子中，通过upstream指令指定了一个负载均衡器的名称iyangyi.com。这个名称可以任意指定，在后面需要的地方直接调用即可。</p><p>里面是ip_hash这是其中的一种负载均衡调度算法，下面会着重介绍。紧接着就是各种服务器了。用server关键字表识，后面接ip。</p><p>Nginx的负载均衡模块目前支持4种调度算法:</p><p>1 weight 轮询（默认）。每个请求按时间顺序逐一分配到不同的后端服务器，如果后端某台服务器宕机，故障系统被自动剔除，使用户访问不受影响。weight。指定轮询权值，weight值越大，分配到的访问机率越高，主要用于后端每个服务器性能不均的情况下。<br>2 ip_hash。每个请求按访问IP的hash结果分配，这样来自同一个IP的访客固定访问一个后端服务器，有效解决了动态网页存在的session共享问题。<br>fair。比上面两个更加智能的负载均衡算法。此种算法可以依据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身是不支持fair的，如果需要使用这种调度算法，必须下载Nginx的upstream_fair模块。<br>3 url_hash。按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身是不支持url_hash的，如果需要使用这种调度算法，必须安装Nginx 的hash软件包。<br>4 在HTTP Upstream模块中，可以通过server指令指定后端服务器的IP地址和端口，同时还可以设定每个后端服务器在负载均衡调度中的状态。常用的状态有：</p><p>down，表示当前的server暂时不参与负载均衡。<br>backup，预留的备份机器。当其他所有的非backup机器出现故障或者忙的时候，才会请求backup机器，因此这台机器的压力最轻。<br>max_fails，允许请求失败的次数，默认为1。当超过最大次数时，返回proxy_next_upstream 模块定义的错误。<br>fail_timeout，在经历了max_fails次失败后，暂停服务的时间。max_fails可以和fail_timeout一起使用。<br>注意 当负载调度算法为ip_hash时，后端服务器在负载均衡调度中的状态不能是weight和backup。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;nginx基本就分为以下几块：&lt;/p&gt;
&lt;h2 id=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;a href=&quot;#nginx配置文件主要分为六个区域：&quot; class=&quot;headerlink&quot; title=&quot;nginx配置文件主要分为六个区域：&quot;&gt;&lt;/a&gt;nginx配置文件
      
    
    </summary>
    
      <category term="HTTP  分类" scheme="/shmilyvidian.site/categories/HTTP-%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
  <entry>
    <title>利用hexo+githubpage+阿里云搭建个人博客</title>
    <link href="/shmilyvidian.site/2017/11/05/hexo/"/>
    <id>/shmilyvidian.site/2017/11/05/hexo/</id>
    <published>2017-11-05T03:07:36.275Z</published>
    <updated>2017-12-03T03:40:08.122Z</updated>
    
    <content type="html"><![CDATA[<h1 id="利用hexo-githubpage-阿里云搭建个人博客"><a href="#利用hexo-githubpage-阿里云搭建个人博客" class="headerlink" title="利用hexo+githubpage+阿里云搭建个人博客"></a>利用hexo+githubpage+阿里云搭建个人博客</h1><hr><p>因为最近在想搞一个自己的博客,发现GitHub+Hexo是最好的一个选择了,折腾了很多，走了很多配置的坑, 发现网上的教程虽然有很多,但是自己一步步操作得形成自己的体系，毕竟自己的东西才是更有意义的，所以记录下来希望可以帮助其他人博客的搭建, 一是为了总结,二是为了让更多的人少走弯路,更快的搭建好自己的博客平台.<br><br><img src="/11/05/hexo/../images/timig.jpg" alt="hexo"></p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>–<br>默认你是github注册用户,电脑已安装node,git</p><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>–<br>Hexo是一个基于Node.js的快速简单的静态博客框架<br>    安装方法:npm install -g hexo</p><h3 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h3><p>–<br>在你新建的博客文件夹中,一开始即当前文件夹为空的前提执行hexo init floder_name<br>然后cd floder_name执行npm i</p><h3 id="hexo基础命令"><a href="#hexo基础命令" class="headerlink" title="hexo基础命令"></a>hexo基础命令</h3><p>–<br>hexo clean<br>hexo g<br>hexo d<br>hexo server -p [prot]</p><h3 id="部署到github"><a href="#部署到github" class="headerlink" title="部署到github"></a>部署到github</h3><p>–<br>配置_config.yml文件</p><h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><pre><code>## Docs: http://hexo.io/docs/deployment.htmldeploy:    type: github    repository: https://github.com/用户名/用户名.github.io.git    branch: master</code></pre><h3 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h3><p>–<br>阿里云购买域名域名解析两种方式<br>1.添加CNAME,活动记录填你github的ip地址   (ping username.github.io)<br>2.添加a,活动记录填你gitHub仓库地址</p><h3 id="主题更换"><a href="#主题更换" class="headerlink" title="主题更换"></a>主题更换</h3><p>– hexo官网主题选择你喜欢的主题后去往github地址下载下来放在不博客地址的themes文件夹中,然后在博客配置文件_config.yml更改theme: your_download_theme_name,其他如需配置根据主题提供者的文档修改即可</p><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>1.每次修改后执行了hexo d都会清除CNAME文件,解决方法你在github你的博客仓库setting手动添加custom domain,或者新建CNAME文件然后写入你的域名地址<br>2.hexo中文地址：<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">https://hexo.io/zh-cn/docs/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;利用hexo-githubpage-阿里云搭建个人博客&quot;&gt;&lt;a href=&quot;#利用hexo-githubpage-阿里云搭建个人博客&quot; class=&quot;headerlink&quot; title=&quot;利用hexo+githubpage+阿里云搭建个人博客&quot;&gt;&lt;/a&gt;利用hex
      
    
    </summary>
    
      <category term="ppt  分类" scheme="/shmilyvidian.site/categories/ppt-%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="标签1" scheme="/shmilyvidian.site/tags/%E6%A0%87%E7%AD%BE1/"/>
    
      <category term="标签2 ( 可选 )" scheme="/shmilyvidian.site/tags/%E6%A0%87%E7%AD%BE2-%E5%8F%AF%E9%80%89/"/>
    
  </entry>
  
</feed>
